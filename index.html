<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Office - Team HQ</title>
  
  <!-- PWA Manifest -->
  <link rel="manifest" href="/manifest.json">
  
  <!-- PWA Meta Tags -->
  <meta name="theme-color" content="#0ea5e9">
  <meta name="description" content="OpenClaw agent workspace dashboard">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Office">
  
  <!-- PWA Icons -->
  <link rel="icon" href="/icons/icon-192.png" sizes="192x192">
  <link rel="apple-touch-icon" href="/icons/icon-192.png">
  
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/apexcharts@3.45.1/dist/apexcharts.min.js"></script>
  <link rel="stylesheet" href="css/all-styles.css?v=9">
  <link rel="stylesheet" href="css/toast.css?v=3">
  <link rel="stylesheet" href="css/loading.css?v=3">
</head>
<body>
  <!-- Mobile menu button -->
  <button class="mobile-menu-btn" id="mobileMenuBtn">â˜°</button>

  <!-- Overlay backdrop -->
  <div class="panel-overlay" id="panelOverlay"></div>

  <div class="office-container">
    <h1 id="officeTime">ğŸ¢ The Office - Loading...</h1>

    <div class="office">
      <!-- Zones -->
      <div class="zone desks">
        <div class="zone-label">Desks</div>
      </div>

      <div class="zone conference">
        <div class="zone-label">Conference Room</div>
        <div class="conference-table"></div>
      </div>

      <div class="zone kitchen">
        <div class="zone-label">Kitchen</div>
      </div>

      <div class="zone finance-corner">
        <div class="zone-label">Finance</div>
      </div>

      <div class="zone adventure-corner">
        <div class="zone-label">Adventure</div>
      </div>

      <div class="zone isla-desk">
        <div class="zone-label" style="text-align: center;">Chief of Staff</div>
      </div>

      <!-- Agents -->
      <div class="agent marcus" data-name="Marcus Chen" data-role="Dev Manager" data-task="Reviewing PR #189" data-quote="Technical debt is just procrastination with a fancier name." data-emoji="ğŸ”§">
        <div class="avatar">ğŸ”§<div class="status-dot status-working"></div><div class="unread-badge">ğŸ’¬</div></div>
        <div class="agent-name">Marcus</div>
        <div class="agent-role">Dev Manager</div>
        <div class="agent-task">Reviewing PR</div>
      </div>

      <div class="agent harper" data-name="Harper Reyes" data-role="QA Manager" data-task="Testing Build 193" data-quote="If you didn't test it, you don't know if it works." data-emoji="ğŸ”">
        <div class="avatar">ğŸ”<div class="status-dot status-working"></div><div class="unread-badge">ğŸ’¬</div></div>
        <div class="agent-name">Harper</div>
        <div class="agent-role">QA Manager</div>
        <div class="agent-task">Testing build</div>
      </div>

      <div class="agent eli" data-name="Eli Vasquez" data-role="Chief Architect" data-task="Reviewing DiveStreams patterns" data-quote="The goal isn't elegant code. It's code that survives next quarter." data-emoji="ğŸ—ï¸">
        <div class="avatar">ğŸ—ï¸<div class="status-dot status-thinking"></div><div class="unread-badge">ğŸ’¬</div></div>
        <div class="agent-name">Eli</div>
        <div class="agent-role">Chief Architect</div>
        <div class="agent-task">Architecture review</div>
      </div>

      <div class="agent sage" data-name="Sage Okonkwo" data-role="Researcher" data-task="Competitor analysis" data-quote="The best feature ideas are already in your support tickets." data-emoji="ğŸ”­">
        <div class="avatar">ğŸ”­<div class="status-dot status-idle"></div><div class="unread-badge">ğŸ’¬</div></div>
        <div class="agent-name">Sage</div>
        <div class="agent-role">Researcher</div>
        <div class="agent-task">Research</div>
      </div>

      <div class="agent julie" data-name="Julie Marquez" data-role="Marketing Manager" data-task="MHC launch copy" data-quote="People don't buy features. They buy better versions of themselves." data-emoji="ğŸ“£">
        <div class="avatar">ğŸ“£<div class="status-dot status-working"></div><div class="unread-badge">ğŸ’¬</div></div>
        <div class="agent-name">Julie</div>
        <div class="agent-role">Marketing</div>
        <div class="agent-task">Launch copy</div>
      </div>

      <div class="agent dash" data-name="Dash" data-role="Dashboard Engineer" data-task="Building office UI" data-quote="Good dashboards make complexity visible. Great ones make it actionable." data-emoji="ğŸ¨">
        <div class="avatar">ğŸ¨<div class="status-dot status-working"></div><div class="unread-badge">ğŸ’¬</div></div>
        <div class="agent-name">Dash</div>
        <div class="agent-role">Dashboard</div>
        <div class="agent-task">Building UI</div>
      </div>

      <div class="agent remy" data-name="Remy Delacroix" data-role="Chef" data-task="Planning tomorrow's dinner" data-quote="You don't need more recipes. You need a system." data-emoji="ğŸ³">
        <div class="avatar">ğŸ³<div class="status-dot status-idle"></div><div class="unread-badge">ğŸ’¬</div></div>
        <div class="agent-name">Remy</div>
        <div class="agent-role">Chef</div>
        <div class="agent-task">Meal planning</div>
      </div>

      <div class="agent lena" data-name="Lena Torres" data-role="Gym Coach" data-task="Reviewing week's progress" data-quote="You don't have to feel like it. You just have to show up." data-emoji="ğŸ’ª">
        <div class="avatar">ğŸ’ª<div class="status-dot status-idle"></div><div class="unread-badge">ğŸ’¬</div></div>
        <div class="agent-name">Lena</div>
        <div class="agent-role">Gym Coach</div>
        <div class="agent-task">Progress review</div>
      </div>

      <div class="agent val" data-name="Val Oduya" data-role="Finance Manager" data-task="Weekly budget prep" data-quote="Wealth isn't about what you make. It's about what you keep." data-emoji="ğŸ’°">
        <div class="avatar">ğŸ’°<div class="status-dot status-working"></div><div class="unread-badge">ğŸ’¬</div></div>
        <div class="agent-name">Val</div>
        <div class="agent-role">Finance</div>
        <div class="agent-task">Budget prep</div>
      </div>

      <div class="agent atlas" data-name="Atlas" data-role="Travel Planner" data-task="Ready for trips" data-quote="The best trip is the one you actually take." data-emoji="ğŸ—ºï¸">
        <div class="avatar">ğŸ—ºï¸<div class="status-dot status-idle"></div><div class="unread-badge">ğŸ’¬</div></div>
        <div class="agent-name">Atlas</div>
        <div class="agent-role">Travel</div>
        <div class="agent-task">Ready</div>
      </div>

      <div class="agent nova" data-name="Nova" data-role="HR Advisor" data-task="Ready to help" data-quote="The most caring thing is often the most direct thing." data-emoji="ğŸŒŸ">
        <div class="avatar">ğŸŒŸ<div class="status-dot status-idle"></div><div class="unread-badge">ğŸ’¬</div></div>
        <div class="agent-name">Nova</div>
        <div class="agent-role">HR</div>
        <div class="agent-task">Ready</div>
      </div>

      <div class="agent isla" data-name="Isla" data-role="Chief of Staff" data-task="Team coordination" data-quote="Sycophants are useless. I'd rather be helpful than agreeable." data-emoji="ğŸï¸">
        <div class="avatar">ğŸï¸<div class="status-dot status-working"></div><div class="unread-badge">ğŸ’¬</div></div>
        <div class="agent-name">Isla</div>
        <div class="agent-role">Chief of Staff</div>
        <div class="agent-task">Coordinating</div>
      </div>
    </div>

    <div class="legend">
      <div class="legend-item"><div class="legend-dot status-working"></div> Working</div>
      <div class="legend-item"><div class="legend-dot status-thinking"></div> Thinking</div>
      <div class="legend-item"><div class="legend-dot status-idle"></div> Idle</div>
      <div class="legend-item"><div class="legend-dot status-meeting"></div> In Meeting</div>
    </div>
  </div>

  <!-- Left Info Panel -->
  <div class="left-info-panel">
    <!-- Tab Navigation -->
    <div class="left-panel-tabs">
      <div class="left-tab active" data-tab="priorities">ğŸ¯ Priorities</div>
      <div class="left-tab" data-tab="standup">ğŸ“‹ Standup</div>
      <div class="left-tab" data-tab="interactions">ğŸ”— Activity</div>
      <button class="settings-btn" id="settingsBtn" title="Notification Settings">âš™ï¸</button>
    </div>

    <!-- Priorities Tab -->
    <div class="left-tab-content active" id="tab-priorities">
      <div class="tab-header">
        <span class="updated" id="prioritiesUpdated"></span>
      </div>
      <div id="prioritiesContent">
        <div class="no-interactions">Loading...</div>
      </div>
    </div>

    <!-- Daily Standup Tab -->
    <div class="left-tab-content" id="tab-standup">
      <div class="tab-header">
        <span class="updated" id="standupDate"></span>
      </div>
      <div id="standupContent">
        <div class="no-interactions">Loading...</div>
      </div>
    </div>

    <!-- Recent Interactions Tab -->
    <div class="left-tab-content" id="tab-interactions">
      <div class="tab-header">Recent Activity</div>
      <div id="interactionFeed">
        <div class="no-interactions">No recent interactions</div>
      </div>
    </div>
  </div>

  <!-- Side Panel -->
  <div class="side-panel hidden" id="sidePanel">
    <div class="resize-handle" id="resizeHandle"></div>
    <div class="panel-header">
      <div class="panel-avatar" id="panelAvatar">ğŸï¸</div>
      <div class="panel-info">
        <h2 id="panelName">Isla</h2>
        <div class="role" id="panelRole">Chief of Staff</div>
      </div>
      <button class="panel-close" id="panelClose">Ã—</button>
    </div>

    <div class="panel-tabs">
      <div class="panel-tab active" data-tab="chat">ğŸ’¬ Chat</div>
      <div class="panel-tab" data-tab="memory">ğŸ§  Memory</div>
      <div class="panel-tab" data-tab="status">ğŸ“Š Status</div>
      <div class="panel-tab" data-tab="files">ğŸ“ Files</div>
    </div>

    <div class="tab-content">
      <!-- Chat Tab -->
      <div class="tab-pane active" id="tab-chat">
        <div class="chat-header-bar" style="padding: 8px 15px; border-bottom: 1px solid #333; display: flex; justify-content: space-between; align-items: center;">
          <span style="font-size: 0.85rem; color: #888;" id="chatChannelName">#hq</span>
          <span id="wsStatus" style="font-size: 0.7rem; color: #555;">Connecting...</span>
        </div>
        <div class="chat-messages" id="chatMessages" style="flex: 1; overflow-y: auto; padding: 15px; min-height: 0;">
          <div class="chat-loading" style="text-align: center; color: #666; padding: 20px;">Loading messages...</div>
        </div>
        <div class="chat-input-container" style="padding: 10px 15px; border-top: 1px solid #333; display: flex; gap: 10px; align-items: flex-end;">
          <textarea id="chatInput" placeholder="Type a message..." style="flex: 1; background: #2a2a2a; border: 1px solid #444; border-radius: 8px; padding: 10px 15px; color: #fff; font-size: 0.9rem; resize: none; min-height: 40px; max-height: 200px; overflow-y: auto; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.4;" rows="1"></textarea>
          <button id="chatSend" style="background: #5865F2; border: none; border-radius: 8px; padding: 10px 20px; color: white; cursor: pointer; font-weight: 500; flex-shrink: 0;">Send</button>
        </div>
      </div>

      <!-- Memory Tab -->
      <div class="tab-pane" id="tab-memory">
        <div class="memory-section">
          <h3>Loading...</h3>
        </div>
      </div>

      <!-- Status Tab -->
      <div class="tab-pane" id="tab-status">
        <div class="status-section">
          <h3>Loading...</h3>
        </div>
      </div>

      <!-- Files Tab -->
      <div class="tab-pane" id="tab-files">
        <div class="files-section">
          <div class="files-header">
            <h3>ğŸ“ Files for Review</h3>
            <div style="display: flex; gap: 5px;">
              <button class="refresh-btn" onclick="expandAllFolders()" title="Expand All">ğŸ“‚</button>
              <button class="refresh-btn" onclick="fetchFiles()" title="Refresh">â†»</button>
            </div>
          </div>
          <div id="filesList" class="files-list">
            <div class="no-files">No files pending review</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Mobile Bottom Navigation -->
  <div class="mobile-bottom-nav" id="mobileBottomNav">
    <select class="mobile-agent-selector" id="mobileAgentSelector">
      <option value="isla">ğŸï¸ Isla - Chief of Staff</option>
      <option value="marcus">ğŸ”§ Marcus - Dev Manager</option>
      <option value="harper">ğŸ” Harper - QA Manager</option>
      <option value="eli">ğŸ—ï¸ Eli - Chief Architect</option>
      <option value="sage">ğŸ”­ Sage - Researcher</option>
      <option value="julie">ğŸ“£ Julie - Marketing</option>
      <option value="dash">ğŸ¨ Dash - Designer</option>
      <option value="remy">ğŸ³ Remy - Chef</option>
      <option value="lena">ğŸ’ª Lena - Fitness Coach</option>
      <option value="val">ğŸ’° Val - Finance</option>
      <option value="atlas">ğŸ—ºï¸ Atlas - Travel</option>
      <option value="nova">ğŸŒŸ Nova - AI Liaison</option>
    </select>
  </div>

  <!-- Settings Modal -->
  <div class="settings-modal hidden" id="settingsModal">
    <div class="settings-content">
      <div class="settings-header">
        <h2>âš™ï¸ Notification Settings</h2>
        <button class="settings-close" id="settingsClose">Ã—</button>
      </div>
      
      <div class="settings-body">
        <div class="settings-section">
          <label class="settings-toggle">
            <input type="checkbox" id="notificationsEnabled" checked>
            <span>Enable push notifications</span>
          </label>
          <div class="settings-help">
            Receive notifications when agents respond
          </div>
        </div>

        <div class="settings-section" id="agentTogglesSection">
          <div class="settings-label">Notify me when these agents respond:</div>
          <div class="agent-toggles" id="agentToggles">
            <!-- Agent toggles will be inserted here -->
          </div>
        </div>

        <div class="settings-section">
          <button class="btn-primary" id="testNotificationBtn">
            ğŸ”” Send Test Notification
          </button>
        </div>

        <div class="settings-section">
          <div class="settings-label">Push Status</div>
          <div class="settings-status" id="pushStatus">
            <span id="pushStatusText">Checking...</span>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    // Toast Notification System (inlined for reliability)
    class ToastManager {
      constructor() {
        this.container = null;
        this.queue = [];
        this.ready = false;
        this.init();
      }

      init() {
        if (document.body) {
          this.createContainer();
        } else {
          document.addEventListener('DOMContentLoaded', () => this.createContainer());
        }
      }

      createContainer() {
        this.container = document.createElement('div');
        this.container.id = 'toast-container';
        this.container.className = 'toast-container';
        document.body.appendChild(this.container);
        this.ready = true;

        this.queue.forEach(({ message, type, duration }) => {
          this.show(message, type, duration);
        });
        this.queue = [];
      }

      show(message, type = 'info', duration = 3000) {
        if (!this.ready) {
          this.queue.push({ message, type, duration });
          return null;
        }

        const toast = document.createElement('div');
        toast.className = `toast toast-${type}`;
        
        const icons = {
          success: 'âœ“',
          error: 'âœ•',
          warning: 'âš ',
          info: 'â„¹'
        };
        
        toast.innerHTML = `
          <span class="toast-icon">${icons[type] || 'â„¹'}</span>
          <span class="toast-message">${this.escapeHtml(message)}</span>
          <button class="toast-close" onclick="this.parentElement.remove()">Ã—</button>
        `;
        
        this.container.appendChild(toast);
        setTimeout(() => toast.classList.add('toast-show'), 10);
        
        if (duration > 0) {
          setTimeout(() => this.dismiss(toast), duration);
        }
        
        return toast;
      }

      dismiss(toast) {
        toast.classList.remove('toast-show');
        toast.classList.add('toast-hide');
        setTimeout(() => toast.remove(), 300);
      }

      escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      success(message, duration = 3000) {
        return this.show(message, 'success', duration);
      }

      error(message, duration = 5000) {
        return this.show(message, 'error', duration);
      }

      warning(message, duration = 4000) {
        return this.show(message, 'warning', duration);
      }

      info(message, duration = 3000) {
        return this.show(message, 'info', duration);
      }
    }

    window.toast = new ToastManager();
    window.showToast = function(message, type = 'info', duration = 3000) {
      return window.toast.show(message, type, duration);
    };

    const sidePanel = document.getElementById('sidePanel');
    const agents = document.querySelectorAll('.agent');
    const panelClose = document.getElementById('panelClose');
    // Note: tab elements are now built dynamically per-agent by buildTabsForAgent()
    const chatInput = document.getElementById('chatInput');
    const chatSend = document.getElementById('chatSend');
    const chatMessages = document.getElementById('chatMessages');

    let selectedAgent = null;

    // Update office time display
    function updateOfficeTime() {
      const now = new Date();
      const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      const dayName = days[now.getDay()];
      const time = now.toLocaleTimeString('en-US', {
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
      document.getElementById('officeTime').textContent = `ğŸ¢ The Office - ${dayName} ${time}`;
    }

    // Update immediately and every minute
    updateOfficeTime();
    setInterval(updateOfficeTime, 60000);

    // Agent greetings
    const agentGreetings = {
      isla: "Hey! What can I help you with?",
      marcus: "What's up? Got a PR for me to look at?",
      harper: "Testing something right now, but I can chat. What's up?",
      eli: "Thinking about patterns. What do you need?",
      sage: "Just found something interesting. What's on your mind?",
      julie: "Hey! Working on some copy. What do you need?",
      dash: "Building something cool. Want to see what I'm working on?",
      remy: "Kitchen's open. What can I help with?",
      lena: "Ready when you are. What's up?",
      val: "Numbers looking good. What do you need?"
    };

    // Agent channel names (no Discord dependency)
    const agentChannels = {
      isla: { name: "#hq" },
      marcus: { name: "#mhc" },
      harper: { name: "#qa" },
      eli: { name: "#cto-dev" },
      sage: { name: "#research" },
      julie: { name: "#marketing" },
      dash: { name: "#dash" },
      remy: { name: "#chef" },
      lena: { name: "#gym" },
      val: { name: "#finance" }
    };

    // API endpoint - same origin (server.js on port 3000)
    const API_BASE = '/api';

    // Cache for agent data
    let agentMemoryCache = {};

    // Fetch agent memory from API
    async function fetchAgentMemory(agentKey) {
      if (agentMemoryCache[agentKey]) return agentMemoryCache[agentKey];
      try {
        const response = await fetch(`${API_BASE}/agent/${agentKey}`);
        if (response.ok) {
          const data = await response.json();
          agentMemoryCache[agentKey] = data;
          return data;
        }
      } catch (e) { console.log('Memory fetch failed:', e); }
      return { knowledge: [{ text: "Unable to load memory" }], learned: [], pending: [] };
    }

    // Clear cache to force refresh
    function clearMemoryCache() {
      agentMemoryCache = {};
    }

    // Status polling
    async function pollStatus() {
      try {
        const response = await fetch(`${API_BASE}/status`);
        if (response.ok) {
          const statuses = await response.json();
          updateStatusIndicators(statuses);
        }
      } catch (e) {
        console.log('Status poll failed:', e);
      }
    }

    function updateStatusIndicators(statuses) {
      for (const [agentKey, status] of Object.entries(statuses)) {
        const agentEl = document.querySelector(`.agent.${agentKey}`);
        if (!agentEl) continue;

        const statusDot = agentEl.querySelector('.status-dot');
        const taskEl = agentEl.querySelector('.agent-task');

        if (statusDot) {
          // Remove all status classes
          statusDot.classList.remove('status-working', 'status-idle', 'status-thinking', 'status-meeting');

          // Add appropriate class
          switch (status.state) {
            case 'working':
              statusDot.classList.add('status-working');
              break;
            case 'thinking':
              statusDot.classList.add('status-thinking');
              break;
            case 'meeting':
              statusDot.classList.add('status-meeting');
              break;
            default:
              statusDot.classList.add('status-idle');
          }
        }

        if (taskEl && status.task) {
          taskEl.textContent = status.task;
        }
      }
    }

    // Poll every 10 seconds
    setInterval(pollStatus, 10000);

    // Initial poll
    pollStatus();

    // Interactions
    async function pollInteractions() {
      try {
        const response = await fetch(`${API_BASE}/interactions/active`);
        if (response.ok) {
          const active = await response.json();
          drawInteractionLines(active);
          updateInteractionFeed(active);
        }
      } catch (e) {
        console.log('Interactions poll failed:', e);
      }
    }

    function drawInteractionLines(interactions) {
      // Remove existing lines
      document.querySelectorAll('.interaction-line').forEach(el => el.remove());
      // Interaction lines disabled - they cause layout thrashing with agent animations.
      // The interaction feed panel shows active conversations instead.
    }

    function updateInteractionFeed(interactions) {
      const feed = document.getElementById('interactionFeed');
      if (!feed) return;

      if (interactions.length === 0) {
        feed.innerHTML = '<div class="no-interactions">No recent interactions</div>';
        return;
      }

      feed.innerHTML = interactions.slice(0, 5).map(i => `
        <div class="interaction-item">
          <span class="interaction-agents">${i.from} â†’ ${i.to}</span>
          <span class="interaction-topic">${i.topic}</span>
        </div>
      `).join('');
    }

    // Poll interactions every 5 seconds
    setInterval(pollInteractions, 5000);
    pollInteractions();

    // Action Items Management
    async function getActionItems() {
      // Fetch from server
      try {
        const response = await fetch(`${API_BASE}/action-items`);
        if (response.ok) {
          const data = await response.json();
          if (data.ok) {
            return data.items;
          }
        }
      } catch (e) {
        console.error('Failed to fetch action items:', e);
      }
      return [];
    }

    async function saveActionItems(items) {
      // Not used anymore - we update individual items via API
    }

    function addActionItem(text) {
      // This is called by the global API function after the item is added server-side
      fetchPriorities(); // Refresh display
    }

    async function handleActionItemToggle(e) {
      const idx = parseInt(e.target.dataset.actionIdx);
      const completed = e.target.checked;

      try {
        const response = await fetch(`${API_BASE}/action-items/${idx}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ completed })
        });

        if (response.ok) {
          // Update parent div styling
          const actionDiv = e.target.closest('.action-item');
          if (completed) {
            actionDiv.classList.add('completed');
          } else {
            actionDiv.classList.remove('completed');
          }
        }
      } catch (e) {
        console.error('Failed to update action item:', e);
        // Revert checkbox on error
        e.target.checked = !completed;
      }
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // API to add action items (called by agents or from console)
    window.addActionItemFromAgent = async function(text, agentName) {
      try {
        const response = await fetch(`${API_BASE}/action-items/add`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text, agent: agentName })
        });

        const result = await response.json();
        if (result.ok) {
          console.log(`âœ… Action item added by ${agentName || 'system'}: ${text}`);
          fetchPriorities(); // Refresh display
          return true;
        }
        return false;
      } catch (e) {
        console.error('Failed to add action item:', e);
        return false;
      }
    };

    // Fetch and display Jeremy's priorities
    async function fetchPriorities() {
      try {
        const response = await fetch(`${API_BASE}/today`);
        if (response.ok) {
          const data = await response.json();
          if (data.ok) {
            renderPriorities(data);
          }
        }
      } catch (e) {
        console.log('Priorities fetch failed:', e);
      }
    }

    async function renderPriorities(data) {
      const container = document.getElementById('prioritiesContent');
      const updatedEl = document.getElementById('prioritiesUpdated');

      if (data.updated) {
        updatedEl.textContent = data.updated;
      }

      let html = '';

      // Action Items (from server)
      const actionItems = await getActionItems();
      if (actionItems.length > 0) {
        const hasCompleted = actionItems.some(item => item.completed);
        html += '<div class="priority-section">';
        html += '<div class="priority-section-title">';
        html += '<span>Action Items</span>';
        if (hasCompleted) {
          html += '<button class="clear-completed-btn" id="clearCompletedBtn">Clear Completed</button>';
        }
        html += '</div>';
        actionItems.forEach((item, idx) => {
          const checkedAttr = item.completed ? 'checked' : '';
          const completedClass = item.completed ? 'completed' : '';
          html += `
            <div class="action-item ${completedClass}">
              <input type="checkbox" ${checkedAttr} data-action-idx="${idx}">
              <span class="action-item-text">${escapeHtml(item.text)}</span>
            </div>
          `;
        });
        html += '</div>';
      }

      if (data.focus && data.focus.length > 0) {
        html += '<div class="priority-section"><div class="priority-section-title">Focus</div>';
        data.focus.forEach(item => {
          html += `<div class="priority-item">${item}</div>`;
        });
        html += '</div>';
      }

      if (data.blocked && data.blocked.length > 0) {
        html += '<div class="priority-section"><div class="priority-section-title">Blocked</div>';
        data.blocked.forEach(item => {
          html += `<div class="priority-item blocked">${item}</div>`;
        });
        html += '</div>';
      }

      if (data.notes && data.notes.length > 0) {
        html += '<div class="priority-section"><div class="priority-section-title">Notes</div>';
        data.notes.forEach(item => {
          html += `<div class="priority-item note">${item}</div>`;
        });
        html += '</div>';
      }

      if (!html) {
        html = '<div class="no-interactions">No priorities set</div>';
      }

      container.innerHTML = html;

      // Attach checkbox event listeners
      container.querySelectorAll('.action-item input[type="checkbox"]').forEach(checkbox => {
        checkbox.addEventListener('change', handleActionItemToggle);
      });

      // Attach clear completed button listener
      const clearBtn = document.getElementById('clearCompletedBtn');
      if (clearBtn) {
        clearBtn.addEventListener('click', clearCompletedActionItems);
      }
    }

    async function clearCompletedActionItems() {
      try {
        const response = await fetch(`${API_BASE}/action-items/clear-completed`, {
          method: 'DELETE'
        });

        if (response.ok) {
          const data = await response.json();
          console.log(`ğŸ—‘ï¸ Cleared ${data.removed} completed action items`);
          fetchPriorities(); // Refresh display
        }
      } catch (e) {
        console.error('Failed to clear completed items:', e);
      }
    }

    // Poll priorities every 30 seconds
    setInterval(fetchPriorities, 30000);
    fetchPriorities();

    // Fetch and display daily standup
    async function fetchStandup() {
      try {
        const response = await fetch(`${API_BASE}/standup`);
        if (response.ok) {
          const data = await response.json();
          if (data.ok) {
            renderStandup(data);
          }
        }
      } catch (e) {
        console.log('Standup fetch failed:', e);
      }
    }

    function renderStandup(data) {
      const container = document.getElementById('standupContent');
      const dateEl = document.getElementById('standupDate');

      if (data.date) {
        dateEl.textContent = `${data.date}${data.time ? ' @ ' + data.time : ''}`;
      }

      if (!data.updates || data.updates.length === 0) {
        container.innerHTML = '<div class="no-interactions">No updates</div>';
        return;
      }

      let html = '';
      
      // Render each agent's update
      data.updates.forEach(update => {
        const hasBlockers = update.blockers && update.blockers.length > 0;
        
        html += `
          <div class="standup-card ${hasBlockers ? 'has-blockers' : ''}">
            <div class="standup-header">
              <span class="agent-emoji">${update.emoji}</span>
              <span class="agent-name">${update.name}</span>
              <span class="agent-role">(${update.role})</span>
            </div>
            <div class="standup-items">
        `;
        
        // Render work items
        if (update.items && update.items.length > 0) {
          update.items.forEach(item => {
            const statusClass = {
              'âœ…': 'done',
              'ğŸ”„': 'progress',
              'â³': 'waiting',
              'âš ï¸': 'blocked'
            }[item.status] || 'progress';
            
            html += `
              <div class="standup-item-line ${statusClass}">
                <span class="status-icon">${item.status}</span>
                <span class="item-text">${escapeHtml(item.text)}</span>
              </div>
            `;
          });
        }
        
        // Render learned insight
        if (update.learned) {
          html += `
            <div class="standup-learned">
              <span class="learned-icon">ğŸ“š</span>
              <span class="learned-text">${escapeHtml(update.learned)}</span>
            </div>
          `;
        }
        
        // Render blockers
        if (hasBlockers) {
          html += `<div class="standup-blockers">`;
          update.blockers.forEach(blocker => {
            html += `<div class="blocker-item">â›” ${escapeHtml(blocker)}</div>`;
          });
          html += `</div>`;
        }
        
        html += `
            </div>
          </div>
        `;
      });
      
      // Render cross-team section if present
      if (data.crossTeam && data.crossTeam.length > 0) {
        html += `
          <div class="standup-cross-team">
            <div class="cross-team-header">ğŸ”— Cross-Team</div>
        `;
        data.crossTeam.forEach(item => {
          html += `<div class="cross-team-item"><strong>${item.agent}:</strong> ${escapeHtml(item.text)}</div>`;
        });
        html += `</div>`;
      }

      container.innerHTML = html;
    }

    // Poll standup every 2 minutes
    setInterval(fetchStandup, 120000);
    fetchStandup();

    // Left Panel Tab Switching
    document.querySelectorAll('.left-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        const targetTab = tab.dataset.tab;

        // Update active tab
        document.querySelectorAll('.left-tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');

        // Update active content
        document.querySelectorAll('.left-tab-content').forEach(c => c.classList.remove('active'));
        document.getElementById(`tab-${targetTab}`).classList.add('active');

        // Save preference
        localStorage.setItem('leftPanelTab', targetTab);
      });
    });

    // Restore last active tab
    const savedTab = localStorage.getItem('leftPanelTab');
    if (savedTab) {
      const tab = document.querySelector(`.left-tab[data-tab="${savedTab}"]`);
      if (tab) tab.click();
    }

    // Folder state persistence
    function getFolderStates() {
      const stored = localStorage.getItem('folderStates');
      return stored ? JSON.parse(stored) : {};
    }

    function saveFolderState(folderPath, isCollapsed) {
      const states = getFolderStates();
      states[folderPath] = isCollapsed;
      localStorage.setItem('folderStates', JSON.stringify(states));
    }

    function isFolderCollapsed(folderPath) {
      const states = getFolderStates();
      if (folderPath in states) return states[folderPath];
      return true; // collapsed by default
    }

    function expandAllFolders() {
      // Clear all folder states (removes collapsed state)
      localStorage.removeItem('folderStates');
      
      // Re-render with all folders expanded
      const container = document.getElementById('filesList');
      container.querySelectorAll('.folder-item').forEach(folder => {
        folder.classList.remove('collapsed');
        const path = folder.dataset.path;
        if (path) saveFolderState(path, false); // Save as expanded
      });
    }

    // Fetch files for review
    async function fetchFiles() {
      try {
        const response = await fetch(`${API_BASE}/files`);
        if (response.ok) {
          const data = await response.json();
          if (data.ok) {
            renderFiles(data.tree || data.files); // Support both formats
          }
        }
      } catch (e) {
        console.log('Files fetch failed:', e);
      }
    }

    function renderFiles(items) {
      const container = document.getElementById('filesList');

      if (!items || items.length === 0) {
        container.innerHTML = '<div class="no-files">No files found</div>';
        return;
      }

      container.innerHTML = renderFileTree(items, 0);

      // Add click handlers for folder headers (icon + name both clickable)
      container.querySelectorAll('.folder-header').forEach(header => {
        header.addEventListener('click', (e) => {
          e.stopPropagation();
          const folder = e.target.closest('.folder-item');
          const folderPath = folder.dataset.path;
          const isCollapsed = folder.classList.toggle('collapsed');

          // Save the state
          saveFolderState(folderPath, isCollapsed);
        });
      });

      // Add click handlers for file items
      container.querySelectorAll('.file-item').forEach(fileItem => {
        fileItem.addEventListener('click', () => {
          const filePath = fileItem.dataset.path;
          const fileName = fileItem.dataset.name;
          viewFile(filePath, fileName);
        });
      });
    }

    function renderFileTree(items, depth = 0) {
      return items.map(item => {
        if (item.type === 'folder') {
          const indent = depth * 15;
          const isCollapsed = isFolderCollapsed(item.path);
          const collapsedClass = isCollapsed ? 'collapsed' : '';
          return `
            <div class="folder-item ${collapsedClass}" style="margin-left: ${indent}px;" data-path="${item.path}">
              <div class="folder-header">
                <span class="folder-toggle">ğŸ“</span>
                <span class="folder-name">${escapeHtml(item.name)}</span>
              </div>
              <div class="folder-children">
                ${renderFileTree(item.children, depth + 1)}
              </div>
            </div>
          `;
        } else {
          const indent = depth * 15;
          return `
            <div class="file-item" style="margin-left: ${indent}px;" data-path="${item.path}" data-name="${escapeHtml(item.name)}">
              <div class="file-name">ğŸ“„ ${escapeHtml(item.name)}</div>
              <div class="file-meta">
                <span>${item.modifiedFormatted}</span>
                <span>${Math.round(item.size / 1024) || 1} KB</span>
              </div>
              <div class="file-preview">${escapeHtml(item.preview)}</div>
            </div>
          `;
        }
      }).join('');
    }

    async function viewFile(filePath, fileName) {
      try {
        const response = await fetch(`${API_BASE}/file/${filePath}`);
        if (response.ok) {
          const data = await response.json();
          if (data.ok) {
            showFileViewer(fileName, data.content);
          }
        }
      } catch (e) {
        alert('Failed to load file: ' + e.message);
      }
    }

    function showFileViewer(fileName, content) {
      const viewer = document.createElement('div');
      viewer.className = 'file-viewer';

      // Check file type
      const isMarkdown = fileName.toLowerCase().endsWith('.md');
      const isHtml = fileName.toLowerCase().endsWith('.html') || fileName.toLowerCase().endsWith('.htm');
      let renderedContent;
      let viewerClass = '';
      let blobUrl = null;

      if (isHtml) {
        // Render HTML in an iframe
        const blob = new Blob([content], { type: 'text/html' });
        blobUrl = URL.createObjectURL(blob);
        viewer.innerHTML = `
          <div class="file-viewer-header">
            <h2>ğŸ“„ ${escapeHtml(fileName)}</h2>
            <button class="file-viewer-close">Close</button>
          </div>
          <iframe src="${blobUrl}" style="flex: 1; border: none; background: #fff; border-radius: 8px;"></iframe>
        `;
      } else if (isMarkdown && typeof marked !== 'undefined') {
        // Configure marked for better rendering
        marked.setOptions({
          breaks: true,
          gfm: true,
          headerIds: true,
          mangle: false
        });
        renderedContent = marked.parse(content);
        viewerClass = 'markdown-view';
        viewer.innerHTML = `
          <div class="file-viewer-header">
            <h2>ğŸ“„ ${escapeHtml(fileName)}</h2>
            <button class="file-viewer-close">Close</button>
          </div>
          <div class="file-viewer-content ${viewerClass}">${renderedContent}</div>
        `;
      } else {
        // Plain text view for non-markdown files
        renderedContent = escapeHtml(content);
        viewer.innerHTML = `
          <div class="file-viewer-header">
            <h2>ğŸ“„ ${escapeHtml(fileName)}</h2>
            <button class="file-viewer-close">Close</button>
          </div>
          <div class="file-viewer-content ${viewerClass}">${renderedContent}</div>
        `;
      }

      document.body.appendChild(viewer);

      // Prevent body scroll on mobile
      document.body.style.overflow = 'hidden';

      // Add close button event listener
      const closeBtn = viewer.querySelector('.file-viewer-close');
      console.log('[File Viewer] Close button found:', closeBtn);
      if (closeBtn) {
        closeBtn.addEventListener('click', (e) => {
          console.log('[File Viewer] Close button clicked!');
          e.preventDefault();
          e.stopPropagation();
          if (blobUrl) {
            console.log('[File Viewer] Revoking blob URL:', blobUrl);
            URL.revokeObjectURL(blobUrl);
          }
          console.log('[File Viewer] Removing viewer');
          document.body.style.overflow = '';
          viewer.remove();
        });
        console.log('[File Viewer] Event listener attached');
      } else {
        console.error('[File Viewer] Close button NOT found!');
      }
    }

    // Poll files every 30 seconds
    setInterval(fetchFiles, 30000);
    fetchFiles();

    // Agent default positions (for returning after interaction)
    const defaultPositions = {
      marcus: { top: 50, left: 40 },
      harper: { top: 50, left: 160 },
      eli: { top: 50, left: 280 },
      sage: { top: 50, left: 400 },
      dash: { top: 170, left: 40 },
      julie: { top: 170, left: 220 },
      remy: { top: 60, right: 100 },
      lena: { top: 140, right: 100 },
      val: { top: 270, right: 100 },
      atlas: { bottom: 90, right: 120 },
      nova: { top: 170, left: 400 },
      isla: { bottom: -10 }
    };

    // Conference table seats (positions around the table)
    const conferenceSeats = [
      { top: 350, left: 120 },  // seat 1
      { top: 350, left: 220 },  // seat 2
      { top: 350, left: 320 },  // seat 3
      { top: 350, left: 420 },  // seat 4
      { top: 430, left: 120 },  // seat 5
      { top: 430, left: 220 },  // seat 6
      { top: 430, left: 320 },  // seat 7
      { top: 430, left: 420 },  // seat 8
    ];

    // Movement state
    let seatAssignments = {}; // agent -> seat index
    let movedAgents = new Set(); // agents currently away from their desk
    let currentMeeting = null; // "standup" | null

    // Show a brief toast notification (auto-removes, no stacking)
    let activeNotification = null;
    function showMovementNotification(text) {
      if (activeNotification) activeNotification.remove();
      const el = document.createElement('div');
      el.style.cssText = 'position:fixed;top:80px;right:20px;background:rgba(14,165,233,0.95);color:#fff;padding:12px 20px;border-radius:8px;font-size:0.85rem;font-weight:500;box-shadow:0 4px 12px rgba(0,0,0,0.3);z-index:200;opacity:0;transition:opacity 0.3s;';
      el.textContent = text;
      document.body.appendChild(el);
      activeNotification = el;
      requestAnimationFrame(() => el.style.opacity = '1');
      setTimeout(() => {
        el.style.opacity = '0';
        setTimeout(() => { el.remove(); if (activeNotification === el) activeNotification = null; }, 300);
      }, 3000);
    }

    // Move agent to a position (CSS transition handles the walk)
    function moveAgent(agentKey, position) {
      const el = document.querySelector(`.agent.${agentKey}`);
      if (!el) return;
      // Override any CSS transforms (e.g., isla's translateX(-50%)) so position is accurate
      el.style.transform = 'none';
      if (position.left !== undefined) { el.style.left = position.left + 'px'; el.style.right = 'auto'; }
      if (position.right !== undefined) { el.style.right = position.right + 'px'; el.style.left = 'auto'; }
      if (position.top !== undefined) { el.style.top = position.top + 'px'; el.style.bottom = 'auto'; }
      if (position.bottom !== undefined) { el.style.bottom = position.bottom + 'px'; el.style.top = 'auto'; }
    }

    // Return agent to their default desk
    function returnToDesk(agentKey) {
      const el = document.querySelector(`.agent.${agentKey}`);
      if (!el) return;
      // Clear all inline position/transform styles - CSS class positions take over
      // The transition property still animates the change smoothly
      el.style.removeProperty('left');
      el.style.removeProperty('right');
      el.style.removeProperty('top');
      el.style.removeProperty('bottom');
      el.style.removeProperty('transform');
      delete seatAssignments[agentKey];
      movedAgents.delete(agentKey);
    }

    // Walk one agent over to another agent's desk
    function walkAgentTo(fromAgent, toAgent) {
      if (movedAgents.has(fromAgent)) return; // already walked somewhere
      const toPos = defaultPositions[toAgent];
      if (!toPos) return;
      // Place the walking agent next to the target (offset by ~80px)
      const dest = {};
      if (toPos.left !== undefined) { dest.top = toPos.top; dest.left = toPos.left + 80; }
      else if (toPos.right !== undefined) { dest.top = toPos.top; dest.right = toPos.right + 80; }
      else { dest.bottom = (toPos.bottom || 35) + 60; dest.left = 280; } // near Isla (centered bottom)
      moveAgent(fromAgent, dest);
      movedAgents.add(fromAgent);
      const fromName = fromAgent.charAt(0).toUpperCase() + fromAgent.slice(1);
      const toName = toAgent.charAt(0).toUpperCase() + toAgent.slice(1);
      showMovementNotification(`${fromName} walked over to ${toName}'s desk`);
    }

    // One agent walks to the other's desk for a chat
    function moveForChat(agentA, agentB) {
      if (movedAgents.has(agentA)) return; // already in position
      walkAgentTo(agentA, agentB);
    }

    // Start a meeting - move everyone to conference
    function startMeeting(meetingType) {
      currentMeeting = meetingType;
      const allAgents = ['isla', 'marcus', 'harper', 'eli', 'sage', 'dash', 'julie', 'remy', 'lena', 'val'];
      allAgents.forEach((agent, idx) => {
        if (idx < conferenceSeats.length) {
          moveAgent(agent, conferenceSeats[idx]);
          seatAssignments[agent] = idx;
          movedAgents.add(agent);
        }
      });
    }

    // End meeting - everyone returns to desks
    function endMeeting() {
      currentMeeting = null;
      ['isla', 'marcus', 'harper', 'eli', 'sage', 'dash', 'julie', 'remy', 'lena', 'val'].forEach(returnToDesk);
    }

    // Poll-driven animation (called every 5s - must be cheap)
    function animateAgentMovement(interactions) {
      if (currentMeeting) return;
      const interacting = new Set();
      for (const i of interactions) {
        interacting.add(i.from);
        interacting.add(i.to);
      }
      // Move newly interacting agents
      const handled = new Set();
      for (const i of interactions) {
        if (handled.has(i.from) || handled.has(i.to)) continue;
        moveForChat(i.from, i.to);
        handled.add(i.from);
        handled.add(i.to);
      }
      // Return agents whose interactions ended
      for (const agent of movedAgents) {
        if (!interacting.has(agent)) returnToDesk(agent);
      }
    }

    // Poll interactions
    const originalPollInteractions = pollInteractions;
    pollInteractions = async function() {
      try {
        const response = await fetch(`${API_BASE}/interactions/active`);
        if (response.ok) {
          const active = await response.json();
          drawInteractionLines(active);
          updateInteractionFeed(active);
          animateAgentMovement(active);
        }
      } catch (e) {
        console.log('Interactions poll failed:', e);
      }
    };

    function renderMemorySection(data, agentKey, quote) {
      const memoryPane = document.getElementById('tab-memory');

      let knowledgeHtml = '';
      if (data.knowledge && data.knowledge.length > 0) {
        knowledgeHtml = data.knowledge.slice(0, 5).map(item =>
          `<div class="memory-item">${item.text}</div>`
        ).join('');
      }

      let learnedHtml = '';
      if (data.learned && data.learned.length > 0) {
        learnedHtml = data.learned.map(item =>
          `<div class="memory-item">
            ${item.text}
            <div class="source">${item.source} â€¢ ${item.when}</div>
          </div>`
        ).join('');
      } else {
        learnedHtml = '<div class="memory-item">No cross-agent learnings yet</div>';
      }

      memoryPane.innerHTML = `
        <div class="memory-section">
          <h3>Current Knowledge</h3>
          ${knowledgeHtml || '<div class="memory-item">No knowledge recorded</div>'}
        </div>

        <div class="memory-section">
          <h3>Learned From Others</h3>
          ${learnedHtml}
        </div>

        <div class="agent-quote">"${quote}"</div>
      `;
    }

    function renderStatusSection(data, quote) {
      const statusPane = document.getElementById('tab-status');

      // Today section (for daily-status agents like Remy, Lena)
      let todayHtml = '';
      if (data.today && data.today.length > 0) {
        todayHtml = `
          <div class="status-section recent-activity">
            <h3>ğŸ“… Today</h3>
            ${data.today.map(item =>
              `<div class="activity-item">
                <span class="activity-text">${item.text}</span>
              </div>`
            ).join('')}
          </div>
        `;
      }

      // Pending section
      let pendingHtml = '';
      if (data.pending && data.pending.length > 0) {
        pendingHtml = `
          <div class="status-section recent-activity">
            <h3>Pending Tasks</h3>
            ${data.pending.map(item =>
              `<div class="activity-item">
                <span class="activity-time">${item.done ? 'âœ…' : 'â³'}</span>
                <span class="activity-text">${item.text}</span>
              </div>`
            ).join('')}
          </div>
        `;
      } else if (!data.today || data.today.length === 0) {
        pendingHtml = `
          <div class="status-section recent-activity">
            <h3>Pending Tasks</h3>
            <div class="activity-item"><span class="activity-text">No pending tasks</span></div>
          </div>
        `;
      }

      statusPane.innerHTML = `
        <div class="status-section">
          <h3>Current Status</h3>
          <div class="status-grid">
            <div class="status-card">
              <div class="label">State</div>
              <div class="value green">Active</div>
            </div>
            <div class="status-card">
              <div class="label">Memory</div>
              <div class="value">${data.knowledge ? data.knowledge.length : 0} items</div>
            </div>
            <div class="status-card">
              <div class="label">Learned</div>
              <div class="value blue">${data.learned ? data.learned.length : 0}</div>
            </div>
            <div class="status-card">
              <div class="label">Today</div>
              <div class="value ${data.today && data.today.length > 0 ? 'green' : 'yellow'}">${data.today ? data.today.length : 0}</div>
            </div>
          </div>
        </div>

        ${todayHtml}
        ${pendingHtml}

        <div class="agent-quote">"${quote}"</div>
      `;
    }

    // Click on agent to open panel
    agents.forEach(agent => {
      agent.addEventListener('click', async () => {
        // Deselect previous
        if (selectedAgent) {
          selectedAgent.classList.remove('selected');
        }

        // Select new
        agent.classList.add('selected');
        selectedAgent = agent;

        // Update panel
        const name = agent.dataset.name;
        const role = agent.dataset.role;
        const emoji = agent.dataset.emoji;
        const quote = agent.dataset.quote;
        const agentKey = agent.classList[1]; // e.g., 'marcus'

        document.getElementById('panelAvatar').textContent = emoji;
        document.getElementById('panelName').textContent = name;
        document.getElementById('panelRole').textContent = role;

        // Update WebSocket status indicator (driven by chatWs state)
        const wsUp = chatWs && chatWs.readyState === 1;
        document.getElementById('wsStatus').textContent = wsUp ? 'Live' : 'Connecting...';
        document.getElementById('wsStatus').style.color = wsUp ? '#22c55e' : '#f59e0b';

        // Load live chat for this agent
        loadAgentChat(agentKey);

        // Show panel immediately
        sidePanel.classList.remove('hidden');

        // Build agent-specific tabs and activate chat
        buildTabsForAgent(agentKey);

        // Fetch and render memory data (async)
        const memoryData = await fetchAgentMemory(agentKey);
        renderMemorySection(memoryData, agentKey, quote);
        renderStatusSection(memoryData, quote);
      });
    });

    // Close panel
    panelClose.addEventListener('click', () => {
      sidePanel.classList.add('hidden');
      if (selectedAgent) {
        selectedAgent.classList.remove('selected');
        selectedAgent = null;
      }
      // Hide overlay on mobile
      if (window.innerWidth <= 1200) {
        panelOverlay.classList.remove('active');
      }
    });

    // Tab click handlers are now attached dynamically by buildTabsForAgent()

    // --- Chat System (WebSocket-based) ---
    let currentAgentKey = null;

    // Load drafts from localStorage on startup
    let messageDrafts = {};
    try {
      const stored = localStorage.getItem('messageDrafts');
      if (stored) messageDrafts = JSON.parse(stored);
    } catch (e) {
      console.error('Failed to load drafts:', e);
    }

    // Per-agent custom tab configuration
    // Chat is always first, Memory and Files are always last
    const AGENT_TABS = {
      isla:   [{ id: 'action-items', label: 'ğŸ“‹ Actions', source: 'action-items' },
               { id: 'sprint', label: 'ğŸ“Š Sprint', source: 'sprint' }],
      marcus: [{ id: 'prs', label: 'ğŸ”€ PRs', source: 'prs' },
               { id: 'backlog', label: 'ğŸ“‹ Backlog', source: 'backlog' }],
      harper: [{ id: 'bugs', label: 'ğŸ› Bugs', source: 'bugs' },
               { id: 'testplans', label: 'âœ… Tests', source: 'testplans' }],
      eli:    [{ id: 'architecture', label: 'ğŸ—ï¸ Arch', source: 'architecture' },
               { id: 'techdebt', label: 'ğŸ”§ Debt', source: 'techdebt' }],
      sage:   [{ id: 'research', label: 'ğŸ“š Research', source: 'research' },
               { id: 'findings', label: 'ğŸ” Findings', source: 'findings' }],
      julie:  [{ id: 'campaigns', label: 'ğŸ“£ Campaigns', source: 'campaigns' },
               { id: 'analytics', label: 'ğŸ“Š Analytics', source: 'analytics' }],
      remy:   [{ id: 'recipes', label: 'ğŸ³ Recipes', source: 'recipes' },
               { id: 'mealplan', label: 'ğŸ“… Meals', source: 'mealplan' }],
      lena:   [{ id: 'workouts', label: 'ğŸ‹ï¸ Workouts', source: 'workouts' },
               { id: 'progress', label: 'ğŸ“ˆ Progress', source: 'progress' }],
      val:    [{ id: 'budget', label: 'ğŸ’° Budget', source: 'budget' },
               { id: 'reports', label: 'ğŸ“Š Reports', source: 'reports' }],
      dash:   [{ id: 'components', label: 'ğŸ–¥ï¸ UI', source: 'components' },
               { id: 'roadmap', label: 'ğŸ“‹ Roadmap', source: 'roadmap' }],
      atlas:  [{ id: 'projects', label: 'ğŸ—ºï¸ Projects', source: 'projects' },
               { id: 'tasks', label: 'ğŸ“‹ Tasks', source: 'tasks' }],
      nova:   [{ id: 'team', label: 'ğŸ‘¥ Team', source: 'team' },
               { id: 'policies', label: 'ğŸ“‹ Policies', source: 'policies' }],
    };

    function buildTabsForAgent(agentKey) {
      const customTabs = AGENT_TABS[agentKey] || [];
      const panelTabsEl = document.querySelector('.panel-tabs');
      const tabContent = document.querySelector('.tab-content');

      // Build tab bar HTML: Chat + custom + Memory + Files
      let tabBarHtml = '<div class="panel-tab active" data-tab="chat">ğŸ’¬ Chat</div>';
      customTabs.forEach(t => {
        tabBarHtml += `<div class="panel-tab" data-tab="${t.id}" data-source="${t.source}">${t.label}</div>`;
      });
      tabBarHtml += '<div class="panel-tab" data-tab="memory">ğŸ§  Memory</div>';
      tabBarHtml += '<div class="panel-tab" data-tab="files">ğŸ“ Files</div>';
      panelTabsEl.innerHTML = tabBarHtml;

      // Remove old custom tab panes (keep chat, memory, status, files)
      tabContent.querySelectorAll('.tab-pane[data-custom]').forEach(p => p.remove());

      // Create panes for custom tabs â€” insert after chat pane
      const chatPane = document.getElementById('tab-chat');
      let insertAfter = chatPane;
      customTabs.forEach(t => {
        const pane = document.createElement('div');
        pane.className = 'tab-pane';
        pane.id = `tab-${t.id}`;
        pane.dataset.custom = 'true';
        pane.dataset.source = t.source;
        pane.dataset.agent = agentKey;
        pane.innerHTML = '<div class="custom-tab-content" style="padding: 15px; overflow-y: auto; flex: 1;"><div style="text-align: center; color: #666; padding: 20px;">Loading...</div></div>';
        insertAfter.after(pane);
        insertAfter = pane;
      });

      // Re-attach tab click handlers
      panelTabsEl.querySelectorAll('.panel-tab').forEach(tab => {
        tab.addEventListener('click', () => {
          panelTabsEl.querySelectorAll('.panel-tab').forEach(t => t.classList.remove('active'));
          tabContent.querySelectorAll('.tab-pane').forEach(p => p.classList.remove('active'));

          tab.classList.add('active');
          const pane = document.getElementById('tab-' + tab.dataset.tab);
          if (pane) {
            pane.classList.add('active');

            // Lazy-load custom tab data on first click
            if (tab.dataset.source && !pane.dataset.loaded) {
              loadCustomTabData(agentKey, tab.dataset.source, pane);
            }
          }
        });
      });

      // Activate chat tab and deactivate all others
      tabContent.querySelectorAll('.tab-pane').forEach(p => p.classList.remove('active'));
      document.getElementById('tab-chat').classList.add('active');
    }

    async function loadCustomTabData(agentKey, source, pane) {
      const container = pane.querySelector('.custom-tab-content');
      try {
        const resp = await fetch(`${API_BASE}/agent-data/${agentKey}/${source}`);
        if (!resp.ok) throw new Error('Failed to fetch');
        const data = await resp.json();

        if (data.empty) {
          const agentName = agentKey.charAt(0).toUpperCase() + agentKey.slice(1);
          container.innerHTML = `<div style="text-align: center; color: #666; padding: 40px 20px;">
            <div style="font-size: 2rem; margin-bottom: 10px;">ğŸ“­</div>
            <p>No data yet.</p>
            <p style="font-size: 0.85rem;">Ask ${agentName} to update this tab.</p>
          </div>`;
        } else if (data.format === 'markdown' && typeof marked !== 'undefined') {
          marked.setOptions({ breaks: true, gfm: true });
          container.innerHTML = `<div class="markdown-view" style="max-width: 800px;">${marked.parse(data.content)}</div>`;
        } else if (data.format === 'json') {
          container.innerHTML = renderAgentDataTable(data.data);
        } else {
          container.textContent = JSON.stringify(data, null, 2);
        }
        pane.dataset.loaded = 'true';
      } catch (e) {
        container.innerHTML = `<div style="text-align: center; color: #f59e0b; padding: 20px;">Failed to load: ${e.message}</div>`;
      }
    }

    function renderAgentDataTable(data) {
      if (Array.isArray(data)) {
        if (data.length === 0) return '<div style="color: #666; text-align: center; padding: 20px;">No items</div>';
        return data.map(item => {
          const entries = Object.entries(item).map(([k, v]) => {
            return `<div style="display: flex; gap: 8px; padding: 4px 0; border-bottom: 1px solid #222;">
              <span style="color: #888; min-width: 100px; font-size: 0.8rem;">${escapeHtml(k)}</span>
              <span style="color: #ddd; font-size: 0.85rem;">${escapeHtml(String(v))}</span>
            </div>`;
          }).join('');
          return `<div style="background: #1a1a2e; border-radius: 8px; padding: 12px; margin-bottom: 8px;">${entries}</div>`;
        }).join('');
      }
      if (typeof data === 'object' && data !== null) {
        const entries = Object.entries(data).map(([k, v]) => {
          const val = typeof v === 'object' ? JSON.stringify(v, null, 2) : String(v);
          return `<div style="display: flex; gap: 8px; padding: 6px 0; border-bottom: 1px solid #222;">
            <span style="color: #888; min-width: 120px; font-weight: 600; font-size: 0.85rem;">${escapeHtml(k)}</span>
            <span style="color: #ddd; font-size: 0.85rem; white-space: pre-wrap;">${escapeHtml(val)}</span>
          </div>`;
        }).join('');
        return `<div style="background: #1a1a2e; border-radius: 8px; padding: 12px;">${entries}</div>`;
      }
      return `<pre style="color: #ddd;">${escapeHtml(String(data))}</pre>`;
    }

    const messageCache = new Map(); // agentKey -> Message[] (populated from server only)
    const streamingState = new Map(); // agentKey -> { el, text }
    const unreadCounts = new Map(); // agentKey -> number

    // Track last known seq per agent for reconciliation
    function getLastSeq(agentKey) {
      const cache = messageCache.get(agentKey);
      if (!cache || cache.length === 0) return 0;
      const realMessages = cache.filter(m => !m._optimistic);
      if (realMessages.length === 0) return 0;
      return realMessages[realMessages.length - 1].seq;
    }

    // Chat v2: WebSocket to backend for message push
    let chatWs = null;
    let chatWsReconnectTimer = null;

    function chatWsConnect() {
      if (chatWs && chatWs.readyState <= 1) return;
      const wsProto = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const url = `${wsProto}//${window.location.host}/ws`;
      console.log('[Chat-WS] Connecting to', url);
      chatWs = new WebSocket(url);

      chatWs.onopen = () => {
        console.log('[Chat-WS] Connected');
        document.getElementById('wsStatus').textContent = 'Live';
        document.getElementById('wsStatus').style.color = '#22c55e';
        if (currentAgentKey) {
          console.log('[Chat-WS] Subscribing to', currentAgentKey);
          const lastSeq = getLastSeq(currentAgentKey);
          chatWs.send(JSON.stringify({ type: 'subscribe', agent: currentAgentKey, lastSeq }));
        }
      };

      chatWs.onmessage = (event) => {
        let msg;
        try { msg = JSON.parse(event.data); } catch { return; }

        if (msg.type === 'history') {
          handleHistory(msg.agent, msg.messages);
        }

        if (msg.type === 'history_update') {
          handleHistoryUpdate(msg.agent, msg.messages);
        }

        if (msg.type === 'message_committed') {
          handleNewMessage(msg.agent, msg.message);
        }

        if (msg.type === 'sync_update') {
          handleHistoryUpdate(msg.agent, msg.messages);
        }

        // Server-owned Gateway streaming events
        if (msg.type === 'stream_delta') {
          updateStreaming(msg.agent, msg.text);
        }

        if (msg.type === 'stream_final') {
          if (!msg.text || msg.filtered) {
            clearStreamingEl(msg.agent);
          }
          // If text is present, the server already committed the message â€”
          // message_committed will follow and replace the streaming element.
        }

        if (msg.type === 'stream_error') {
          console.error('[Stream] Error from', msg.agent, msg.error);
          clearStreamingEl(msg.agent);
        }
      };

      chatWs.onclose = () => {
        console.log('[Chat-WS] Disconnected, reconnecting in 3s');
        const wsEl = document.getElementById('wsStatus');
        if (wsEl) { wsEl.textContent = 'Reconnecting...'; wsEl.style.color = '#f59e0b'; }
        chatWsReconnectTimer = setTimeout(chatWsConnect, 3000);
      };

      chatWs.onerror = (e) => {
        console.error('[Chat-WS] Error:', e);
      };
    }

    chatWsConnect();

    // Periodic reconciliation â€” check all agents for missed messages every 30s
    function reconcileAllAgents() {
      if (!chatWs || chatWs.readyState !== 1) return;

      const agents = {};
      for (const [agent, cache] of messageCache) {
        agents[agent] = getLastSeq(agent);
      }

      if (Object.keys(agents).length > 0) {
        chatWs.send(JSON.stringify({ type: 'sync', agents }));
      }
    }

    setInterval(reconcileAllAgents, 30000);

    // Reconcile immediately when tab becomes visible (e.g., switching back from iPad app)
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') {
        // Small delay to let WebSocket reconnect if it dropped
        setTimeout(() => {
          reconcileAllAgents();
          // Also re-subscribe to current agent to get fresh state
          if (currentAgentKey && chatWs && chatWs.readyState === 1) {
            const lastSeq = getLastSeq(currentAgentKey);
            chatWs.send(JSON.stringify({ type: 'subscribe', agent: currentAgentKey, lastSeq }));
          }
        }, 500);
      }
    });

    function handleHistory(agent, messages) {
      messageCache.set(agent, messages);
      if (agent === currentAgentKey) {
        renderAllMessages(agent, messages);
      }
    }

    // Incremental history update â€” append only new messages
    function handleHistoryUpdate(agent, messages) {
      if (!messageCache.has(agent)) messageCache.set(agent, []);
      const cache = messageCache.get(agent);

      let added = 0;
      for (const msg of messages) {
        // Skip if we already have this seq
        if (cache.some(m => !m._optimistic && m.seq === msg.seq)) continue;

        // Replace optimistic message if content matches
        const optIdx = cache.findIndex(m => m._optimistic && m.content === msg.content);
        if (optIdx !== -1) {
          cache[optIdx] = msg;
        } else {
          cache.push(msg);
          added++;
        }
      }

      // Sort by seq to maintain order
      if (added > 0) {
        cache.sort((a, b) => (a.seq || 0) - (b.seq || 0));

        if (agent === currentAgentKey) {
          renderAllMessages(agent, cache);
        } else {
          unreadCounts.set(agent, (unreadCounts.get(agent) || 0) + added);
          const agentEl = document.querySelector(`.agent.${agent}`);
          if (agentEl) agentEl.classList.add('has-unread');
        }
      }
    }

    function handleNewMessage(agent, message) {
      if (!messageCache.has(agent)) messageCache.set(agent, []);
      const cache = messageCache.get(agent);

      // Dedupe by seq â€” skip if already in cache (but ignore optimistic entries with _optimistic flag)
      const lastReal = cache.filter(m => !m._optimistic).pop();
      if (lastReal && lastReal.seq >= message.seq) return;

      // Replace optimistic entry with matching content (works for both user and bot messages)
      const optIdx = cache.findIndex(m => m._optimistic && m.content === message.content);
      if (optIdx !== -1) {
        cache[optIdx] = message; // replace optimistic with real
        return; // already displayed
      }

      cache.push(message);

      if (agent === currentAgentKey) {
        if (message.isBot) {
          clearStreamingEl(agent);
        }
        appendMessageEl(message);
        autoScroll();
      } else {
        unreadCounts.set(agent, (unreadCounts.get(agent) || 0) + 1);
        const agentEl = document.querySelector(`.agent.${agent}`);
        if (agentEl) agentEl.classList.add('has-unread');
      }
    }

    function createMessageEl(m) {
      const isUser = !m.isBot;
      const agentEl = document.querySelector(`.agent.${currentAgentKey}`);
      const agentEmoji = agentEl?.dataset?.emoji || 'ğŸ¤–';

      const el = document.createElement('div');
      el.className = `message-bubble ${isUser ? 'you' : 'them'}`;
      el.dataset.seq = m.seq;
      el.innerHTML = `
        <div class="bubble-avatar ${isUser ? 'jeremy' : 'bot'}">${isUser ? 'ğŸ‘‘' : agentEmoji}</div>
        <div class="bubble-content">
          <div class="bubble-text">${isUser ? escapeHtml(m.content || '') : formatMarkdown(m.content || '')}</div>
          <div class="bubble-time">${m.timestampFormatted || ''}</div>
        </div>`;
      return el;
    }

    function renderAllMessages(agent, messages) {
      const filtered = messages.filter(m => {
        if (!m.isBot) return true;
        const content = (m.content || '').trim();
        return !/^(NO_REPLY|NO_?|HEARTBEAT_OK|HEARTBEAT_?|ANNOUNCE_SKIP|ANNOUNCE_?)\s*$/i.test(content);
      });

      if (filtered.length === 0) {
        chatMessages.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">Start a conversation...</div>';
        return;
      }

      chatMessages.innerHTML = '';
      const fragment = document.createDocumentFragment();
      for (const m of filtered) {
        fragment.appendChild(createMessageEl(m));
      }
      chatMessages.appendChild(fragment);

      const ss = streamingState.get(agent);
      if (ss?.el) {
        chatMessages.appendChild(ss.el);
      }

      setTimeout(() => renderPendingCharts(), 50);

      requestAnimationFrame(() => {
        chatMessages.scrollTop = chatMessages.scrollHeight;
      });
    }

    function appendMessageEl(message) {
      if (message.isBot) {
        const content = (message.content || '').trim();
        if (/^(NO_REPLY|NO_?|HEARTBEAT_OK|HEARTBEAT_?|ANNOUNCE_SKIP|ANNOUNCE_?)\s*$/i.test(content)) return;
      }

      const placeholder = chatMessages.querySelector('div[style*="text-align: center"]');
      if (placeholder) placeholder.remove();

      chatMessages.appendChild(createMessageEl(message));
      setTimeout(() => renderPendingCharts(), 50);
    }

    function autoScroll() {
      const threshold = 150;
      const distFromBottom = chatMessages.scrollHeight - chatMessages.scrollTop - chatMessages.clientHeight;
      if (distFromBottom < threshold) {
        requestAnimationFrame(() => {
          chatMessages.scrollTop = chatMessages.scrollHeight;
        });
      }
    }

    // Chart ID counter for unique chart containers
    let chartIdCounter = 0;

    // Store chart configs to render after DOM insertion
    const pendingCharts = new Map();

    // Detect and extract chart data from text (JSON format)
    function extractChartData(text) {
      const charts = [];
      // Match code blocks that look like chart JSON
      const codeBlockPattern = /```(?:json|chart)?\s*\n?([\s\S]*?)```/g;
      let match;

      while ((match = codeBlockPattern.exec(text)) !== null) {
        try {
          const jsonStr = match[1].trim();
          const data = JSON.parse(jsonStr);

          // Check if it's a chart object
          if (data.type === 'chart' && data.chartType && data.data) {
            charts.push({
              raw: match[0],
              data: data,
              position: match.index
            });
          }
        } catch (e) {
          // Not valid JSON or not a chart, skip
        }
      }

      return charts;
    }

    // Render a chart using ApexCharts
    function renderChart(chartData) {
      const chartId = `chart-${++chartIdCounter}`;
      const { chartType, title, data, options = {} } = chartData;

      // Build ApexCharts options based on chart type
      let apexOptions = {
        chart: {
          type: chartType,
          height: 300,
          background: 'transparent',
          foreColor: '#e0e0e0',
          toolbar: {
            show: true,
            tools: {
              download: true,
              zoom: chartType === 'line' || chartType === 'area',
              pan: chartType === 'line' || chartType === 'area'
            }
          },
          animations: {
            enabled: true,
            speed: 800
          }
        },
        theme: {
          mode: 'dark'
        },
        grid: {
          borderColor: '#444',
          strokeDashArray: 3
        },
        tooltip: {
          theme: 'dark',
          style: {
            fontSize: '12px'
          }
        },
        legend: {
          position: 'bottom',
          labels: {
            colors: '#e0e0e0'
          }
        }
      };

      // Handle different chart types
      if (chartType === 'line' || chartType === 'area') {
        apexOptions.series = data.series;
        apexOptions.xaxis = {
          categories: data.labels,
          labels: {
            style: {
              colors: '#888'
            }
          }
        };
        apexOptions.yaxis = {
          title: {
            text: options.yAxisTitle || '',
            style: {
              color: '#888'
            }
          },
          labels: {
            style: {
              colors: '#888'
            }
          }
        };

        // Add goal line if specified
        if (options.goal) {
          apexOptions.annotations = {
            yaxis: [{
              y: options.goal,
              borderColor: '#f59e0b',
              strokeDashArray: 5,
              label: {
                text: `Goal: ${options.goal}`,
                style: {
                  color: '#fff',
                  background: '#f59e0b'
                }
              }
            }]
          };
        }

        apexOptions.stroke = {
          curve: 'smooth',
          width: 2
        };
      } else if (chartType === 'bar') {
        apexOptions.series = data.series;
        apexOptions.xaxis = {
          categories: data.labels,
          labels: {
            style: {
              colors: '#888'
            }
          }
        };
        apexOptions.yaxis = {
          title: {
            text: options.yAxisTitle || '',
            style: {
              color: '#888'
            }
          },
          labels: {
            style: {
              colors: '#888'
            }
          }
        };
        apexOptions.plotOptions = {
          bar: {
            borderRadius: 4,
            horizontal: options.horizontal || false
          }
        };
      } else if (chartType === 'pie' || chartType === 'donut') {
        apexOptions.series = data.values;
        apexOptions.labels = data.labels;
        apexOptions.chart.type = chartType;
      }

      // Store chart config for later rendering
      pendingCharts.set(chartId, apexOptions);

      // Return HTML for chart container (no script tag)
      const titleHtml = title ? `<div class="chart-title">${escapeHtml(title)}</div>` : '';
      return `
        <div class="chart-container">
          ${titleHtml}
          <div id="${chartId}" class="chart-wrapper" data-chart-pending="true"></div>
        </div>
      `;
    }

    // Render all pending charts after DOM insertion
    function renderPendingCharts() {
      if (typeof ApexCharts === 'undefined') {
        console.error('[CHART] ApexCharts not loaded!');
        return;
      }

      // Find all chart containers waiting to be rendered
      const pending = document.querySelectorAll('[data-chart-pending="true"]');
      console.log('[CHART] Rendering', pending.length, 'pending chart(s)');

      pending.forEach(container => {
        const chartId = container.id;
        const options = pendingCharts.get(chartId);

        if (options) {
          console.log('[CHART] Rendering chart:', chartId);
          // Remove the pending flag
          container.removeAttribute('data-chart-pending');

          // Render the chart
          const chart = new ApexCharts(container, options);
          chart.render();

          // Clean up
          pendingCharts.delete(chartId);
        }
      });
    }

    // Format markdown for messages (with chart support)
    function formatMarkdown(text) {
      if (!text) return '';

      // Extract any chart data first
      const charts = extractChartData(text);

      // Replace charts with placeholders before markdown processing
      let processedText = text;
      const chartPlaceholders = [];
      if (charts.length > 0) {
        console.log('[CHART] Found', charts.length, 'chart(s)');
        charts.forEach((chart, idx) => {
          // Use HTML comment as placeholder - markdown won't touch it
          const placeholder = `<!--CHART_${idx}-->`;
          chartPlaceholders.push(renderChart(chart.data));
          processedText = processedText.replace(chart.raw, placeholder);
        });
      }

      // Process markdown
      let html;
      if (typeof marked === 'undefined') {
        // Fallback to simple formatting if marked isn't loaded
        html = escapeHtml(processedText);
        html = html.replace(/```(\w*)\n?([\s\S]*?)```/g, '<pre><code>$2</code></pre>');
        html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
        html = html.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
        html = html.replace(/\*([^*]+)\*/g, '<em>$1</em>');
        html = html.replace(/~~([^~]+)~~/g, '<del>$1</del>');
        html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>');
        html = html.replace(/(https?:\/\/[^\s<]+)/g, '<a href="$1" target="_blank">$1</a>');
      } else {
        // Use marked for proper markdown rendering
        marked.setOptions({
          breaks: true,
          gfm: true,
          headerIds: false,
          mangle: false
        });
        html = marked.parse(processedText);
      }

      // Replace placeholders with actual chart HTML
      if (chartPlaceholders.length > 0) {
        console.log('[CHART] Replacing', chartPlaceholders.length, 'placeholder(s)');
        chartPlaceholders.forEach((chartHtml, idx) => {
          const placeholder = `<!--CHART_${idx}-->`;
          const beforeCount = html.split(placeholder).length - 1;
          html = html.split(placeholder).join(chartHtml);
          const afterCount = html.split(placeholder).length - 1;
          console.log('[CHART] Placeholder', idx, '- found:', beforeCount, 'replaced:', beforeCount - afterCount);
        });
      }

      return html;
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function getOrCreateStreamingEl(agentKey) {
      let ss = streamingState.get(agentKey);
      if (ss?.el) return ss.el;

      const agentEl = document.querySelector(`.agent.${agentKey}`);
      const emoji = agentEl?.dataset?.emoji || 'ğŸ¤–';
      const ts = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });

      const el = document.createElement('div');
      el.className = 'message-bubble them streaming';
      el.innerHTML = `
        <div class="bubble-avatar bot">${emoji}</div>
        <div class="bubble-content">
          <div class="bubble-text streaming-text"><span class="typing-indicator">Thinking...</span></div>
          <div class="bubble-time">${ts}</div>
        </div>`;

      ss = { el, text: '' };
      streamingState.set(agentKey, ss);

      if (currentAgentKey === agentKey) {
        chatMessages.appendChild(el);
        autoScroll();
      }

      return el;
    }

    function updateStreaming(agentKey, text) {
      const ss = streamingState.get(agentKey);
      if (!ss) {
        getOrCreateStreamingEl(agentKey);
        return updateStreaming(agentKey, text);
      }
      if (text.length < ss.text.length) return;
      ss.text = text;
      const textEl = ss.el.querySelector('.streaming-text');
      if (textEl) {
        textEl.innerHTML = formatMarkdown(text);
        setTimeout(() => renderPendingCharts(), 50);
      }
      if (currentAgentKey === agentKey) autoScroll();
    }

    function clearStreamingEl(agentKey) {
      const ss = streamingState.get(agentKey);
      if (ss?.el?.parentElement) ss.el.remove();
      streamingState.delete(agentKey);
    }

    // Save draft message for current agent
    function saveDraftForCurrentAgent() {
      if (currentAgentKey && chatInput.value.trim()) {
        messageDrafts[currentAgentKey] = chatInput.value;
      } else if (currentAgentKey) {
        delete messageDrafts[currentAgentKey];
      }
      // Persist to localStorage
      try {
        localStorage.setItem('messageDrafts', JSON.stringify(messageDrafts));
      } catch (e) {
        console.error('Failed to save drafts:', e);
      }
    }

    // Load draft message for agent
    function loadDraftForAgent(agentKey) {
      const draft = messageDrafts[agentKey] || '';
      chatInput.value = draft;
      
      // Only auto-resize if there's actual content, otherwise reset to single line
      if (draft.trim()) {
        autoResizeTextarea();
      } else {
        chatInput.style.height = '40px'; // Reset to min-height (single line)
      }
    }

    // Load chat for an agent
    async function loadAgentChat(agentKey) {
      if (currentAgentKey === agentKey) return;

      saveDraftForCurrentAgent();

      currentAgentKey = agentKey;

      loadDraftForAgent(agentKey);

      // Clear unread
      unreadCounts.set(agentKey, 0);
      const agentEl = document.querySelector(`.agent.${agentKey}`);
      if (agentEl) agentEl.classList.remove('has-unread');

      const channelName = agentChannels[agentKey]?.name || `#${agentKey}`;
      document.getElementById('chatChannelName').textContent = channelName;

      chatMessages.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">Loading messages...</div>';

      // Render cached messages immediately while subscribe refreshes
      const cached = messageCache.get(agentKey);
      if (cached && cached.length > 0) {
        renderAllMessages(agentKey, cached);
      }

      // Subscribe via chat WebSocket â€” or fall back to REST if not connected
      if (chatWs && chatWs.readyState === 1) {
        const lastSeq = getLastSeq(agentKey);
        chatWs.send(JSON.stringify({ type: 'subscribe', agent: agentKey, lastSeq }));
      } else {
        // WebSocket not ready yet â€” fetch via REST API as fallback
        console.log('[Chat] WS not ready, fetching via REST for', agentKey);
        try {
          const resp = await fetch(`/api/chat/${agentKey}`);
          if (resp.ok) {
            const data = await resp.json();
            if (data.messages) {
              handleHistory(agentKey, data.messages);
            }
          }
        } catch (e) {
          console.error('[Chat] REST fallback failed:', e);
        }
      }

      // Streaming is now handled server-side â€” stream_delta/stream_final/stream_error
      // events arrive via chatWs from the backend Gateway connection
    }

    // Parse natural language for movement commands
    function parseNaturalLanguage(text, currentAgent) {
      const lower = text.toLowerCase();
      const agentNames = ['isla', 'marcus', 'harper', 'eli', 'sage', 'dash', 'julie', 'remy', 'lena', 'val'];

      console.log('[NL Parser] Checking:', text, 'Current agent:', currentAgent);

      // Meeting/standup triggers
      if (lower.match(/\b(standup|stand[\s-]?up|daily|meeting|gather|conference)\b/)) {
        if (lower.match(/\b(everyone|all|team|agents)\b/) || lower.includes('time')) {
          showMovementNotification('ğŸ“… Everyone is heading to the conference room...');
          startMeeting('standup');
          return { handled: true, silent: false }; // Let agent respond too
        }
      }

      // End meeting triggers
      if (lower.match(/\b(back to|return to|end|dismiss|done)\b/) && lower.match(/\b(desk|desks|meeting)\b/)) {
        showMovementNotification('âœ… Meeting ended - everyone returning to desks');
        endMeeting();
        return { handled: true, silent: false };
      }

      // Talk to / meet with / go see patterns
      const talkPatterns = [
        /\b(?:go\s+)?(?:talk|speak|chat|meet|ask)\s+(?:(?:to|with)\s+)?(\w+)/i,
        /\b(?:go\s+)?(?:see|visit|check in with|sync with)\s+(\w+)/i,
        /\b(?:walk|head|hop|swing)\s+(?:over\s+)?(?:to\s+)?(\w+)/i,
        /\bcoordinate\s+with\s+(\w+)/i,
        /\bdiscuss\s+(?:this\s+)?(?:with\s+)?(\w+)/i,
      ];

      for (const pattern of talkPatterns) {
        const match = text.match(pattern);
        if (match) {
          console.log('[NL Parser] Pattern matched:', pattern, 'Target:', match[1]);
          const targetAgent = match[1].toLowerCase();
          console.log('[NL Parser] Target agent:', targetAgent, 'Current:', currentAgent, 'Valid:', agentNames.includes(targetAgent));

          if (agentNames.includes(targetAgent) && targetAgent !== currentAgent) {
            console.log('[NL Parser] âœ… Movement triggered!');
            // Show notification
            const currentName = currentAgent.charAt(0).toUpperCase() + currentAgent.slice(1);
            const targetName = targetAgent.charAt(0).toUpperCase() + targetAgent.slice(1);
            showMovementNotification(`${currentName} is walking over to ${targetName}...`);

            // Move current agent to target agent IMMEDIATELY (not delayed)
            console.log('[NL Parser] Calling moveForChat now...');
            moveForChat(currentAgent, targetAgent);

            // Return to desk after 8 seconds
            setTimeout(() => {
              console.log('[NL Parser] Returning to desk...');
              returnToDesk(currentAgent);
              showMovementNotification(`${currentName} returned to their desk`);
            }, 8000);
            return { handled: true, silent: false }; // Continue with message
          } else {
            console.log('[NL Parser] âŒ Skipped - same agent or invalid');
          }
        }
      }

      return { handled: false, silent: false };
    }

    // Check for special commands
    function handleSpecialCommands(text) {
      const cmd = text.toLowerCase().trim();

      // Meeting commands
      if (cmd === '/standup' || cmd === '/meeting') {
        startMeeting('standup');
        return { handled: true, response: 'ğŸ“… Starting standup - everyone to the conference room!' };
      }

      if (cmd === '/endmeeting' || cmd === '/desks') {
        endMeeting();
        return { handled: true, response: 'âœ… Meeting ended - back to your desks!' };
      }

      // Manual interaction trigger (for testing)
      const interactionMatch = cmd.match(/^\/talk\s+(\w+)\s+(\w+)$/);
      if (interactionMatch) {
        const [, agentA, agentB] = interactionMatch;
        moveForChat(agentA, agentB);
        return { handled: true, response: `ğŸ’¬ ${agentA} is talking with ${agentB}` };
      }

      // Return to desk command
      const deskMatch = cmd.match(/^\/desk\s+(\w+)$/);
      if (deskMatch) {
        const agent = deskMatch[1];
        returnToDesk(agent);
        return { handled: true, response: `ğŸš¶ ${agent} returned to their desk` };
      }

      // Help command
      if (cmd === '/help' || cmd === '/commands') {
        return {
          handled: true,
          response: `**Office Controls:**

**Natural Language:**
- "Go talk to Isla about XYZ"
- "Everyone gather for standup"
- "Meeting time"
- "Back to your desks"
- "See Marcus about the PR"

**Slash Commands:**
/standup - Start a meeting
/endmeeting - End meeting
/talk [agent1] [agent2] - Make agents chat
/desk [agent] - Send agent to desk`
        };
      }

      return { handled: false };
    }

    // Send message via Gateway WebSocket
    async function sendMessage() {
      const text = chatInput.value.trim();
      if (!text || !currentAgentKey) return;

      console.log('[SEND] Sending message:', text.substring(0, 50));

      const nlResult = parseNaturalLanguage(text, currentAgentKey);

      const cmdResult = handleSpecialCommands(text);
      if (cmdResult.handled) {
        chatInput.value = '';
        chatInput.style.height = 'auto';
        clearTimeout(draftSaveTimer);
        delete messageDrafts[currentAgentKey];
        localStorage.setItem('messageDrafts', JSON.stringify(messageDrafts));
        const sysEl = document.createElement('div');
        sysEl.style.cssText = 'text-align: center; padding: 12px; margin: 8px 0; background: rgba(14, 165, 233, 0.1); border-radius: 8px; font-size: 0.85rem;';
        sysEl.innerHTML = formatMarkdown(cmdResult.response);
        chatMessages.appendChild(sysEl);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        chatInput.focus();
        return;
      }

      chatInput.value = '';
      chatInput.style.height = 'auto';
      clearTimeout(draftSaveTimer);
      delete messageDrafts[currentAgentKey];
      localStorage.setItem('messageDrafts', JSON.stringify(messageDrafts));

      // Optimistically display user message immediately
      const now = Date.now();
      const idempotencyKey = `user-${now}-${Math.random().toString(36).slice(2)}`;
      const optimisticMsg = {
        seq: now, // temporary seq, will be replaced by server seq on next history load
        agent: currentAgentKey,
        content: text,
        isBot: false,
        author: 'Jeremy',
        authorId: 'user',
        timestamp: now,
        timestampFormatted: new Date(now).toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' }),
        _optimistic: true
      };

      if (!messageCache.has(currentAgentKey)) messageCache.set(currentAgentKey, []);
      messageCache.get(currentAgentKey).push(optimisticMsg);
      appendMessageEl(optimisticMsg);
      autoScroll();

      // Send via backend REST â€” server commits user message and forwards to Gateway
      try {
        const resp = await fetch(`${API_BASE}/chat/${currentAgentKey}/send`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ content: text })
        });
        const data = await resp.json();
        if (!data.ok) {
          const errEl = document.createElement('div');
          errEl.style.cssText = 'text-align: center; color: #f59e0b; padding: 8px; font-size: 0.8rem;';
          errEl.textContent = `Send error: ${data.error || 'Unknown error'}`;
          chatMessages.appendChild(errEl);
          autoScroll();
        }
      } catch (e) {
        console.error('[Chat] send failed:', e);
        const errEl = document.createElement('div');
        errEl.style.cssText = 'text-align: center; color: #f59e0b; padding: 8px; font-size: 0.8rem;';
        errEl.textContent = `Failed to send: ${e.message}`;
        chatMessages.appendChild(errEl);
        autoScroll();
      }

      chatInput.focus();
    }

    // Auto-resize textarea as user types
    function autoResizeTextarea() {
      chatInput.style.height = 'auto';
      chatInput.style.height = Math.min(chatInput.scrollHeight, 200) + 'px';
    }

    // Debounced draft save
    let draftSaveTimer = null;
    function onInputChange() {
      autoResizeTextarea();

      // Debounce draft saving (save 500ms after user stops typing)
      clearTimeout(draftSaveTimer);
      draftSaveTimer = setTimeout(() => {
        saveDraftForCurrentAgent();
      }, 500);
    }

    chatInput.addEventListener('input', onInputChange);

    chatSend.addEventListener('click', sendMessage);
    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });

    // --- Mobile Menu Controls ---
    const mobileMenuBtn = document.getElementById('mobileMenuBtn');
    const leftInfoPanel = document.querySelector('.left-info-panel');
    const panelOverlay = document.getElementById('panelOverlay');

    // Initialize panel as hidden on mobile and ensure overlay is not active
    if (window.innerWidth <= 768) {
      leftInfoPanel.classList.add('mobile-hidden');
      leftInfoPanel.classList.remove('mobile-visible');
      panelOverlay.classList.remove('active'); // Ensure overlay is hidden on load
    }

    // Toggle left panel on mobile
    if (mobileMenuBtn) {
      mobileMenuBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        console.log('Hamburger menu clicked');

        const isVisible = leftInfoPanel.classList.contains('mobile-visible');

        if (isVisible) {
          leftInfoPanel.classList.remove('mobile-visible');
          leftInfoPanel.classList.add('mobile-hidden');
          panelOverlay.classList.remove('active');
        } else {
          leftInfoPanel.classList.remove('mobile-hidden');
          leftInfoPanel.classList.add('mobile-visible');
          panelOverlay.classList.add('active');
        }
      });
    }

    // Close panels when clicking overlay
    if (panelOverlay) {
      panelOverlay.addEventListener('click', () => {
        // Close left panel
        if (leftInfoPanel.classList.contains('mobile-visible')) {
          leftInfoPanel.classList.remove('mobile-visible');
          leftInfoPanel.classList.add('mobile-hidden');
        }
        // Close right panel
        if (!sidePanel.classList.contains('hidden')) {
          sidePanel.classList.add('hidden');
          if (selectedAgent) {
            selectedAgent.classList.remove('selected');
            selectedAgent = null;
          }
        }
        panelOverlay.classList.remove('active');
      });
    }

    // --- Mobile Bottom Navigation ---
    const mobileBottomNav = document.getElementById('mobileBottomNav');
    const mobileAgentSelector = document.getElementById('mobileAgentSelector');

    // Handle mobile dropdown change
    if (mobileAgentSelector) {
      mobileAgentSelector.addEventListener('change', () => {
        const agentKey = mobileAgentSelector.value;

        // Find the corresponding agent element
        const agent = document.querySelector(`.agent.${agentKey}`);
        if (agent) {
          agent.click(); // Trigger existing click handler
        }

        // Show side panel on mobile
        sidePanel.classList.remove('hidden');
      });
    }

    // Update mobile nav active state when agent changes
    function updateMobileNavActive(agentKey) {
      if (mobileAgentSelector) {
        mobileAgentSelector.value = agentKey;
      }
    }

    // Override agent click to show overlay on mobile
    const originalAgentClick = agents.forEach;
    agents.forEach(agent => {
      const existingListener = agent.onclick;
      agent.addEventListener('click', () => {
        // Update mobile nav when agent clicked from office view
        const agentKey = agent.classList[1];
        updateMobileNavActive(agentKey);

        // Show overlay on tablet (not on mobile since chat is primary interface there)
        if (window.innerWidth > 768 && window.innerWidth <= 1200) {
          panelOverlay.classList.add('active');
        }
      });
    });

    // --- Panel Resize ---
    const resizeHandle = document.getElementById('resizeHandle');
    let isResizing = false;
    let startX = 0;
    let startWidth = 0;

    // Load saved width from localStorage
    const savedWidth = localStorage.getItem('sidePanelWidth');
    if (savedWidth) {
      sidePanel.style.width = savedWidth + 'px';
    }

    resizeHandle.addEventListener('mousedown', (e) => {
      isResizing = true;
      startX = e.clientX;
      startWidth = sidePanel.offsetWidth;
      resizeHandle.classList.add('dragging');
      document.body.style.cursor = 'ew-resize';
      document.body.style.userSelect = 'none';
      e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
      if (!isResizing) return;

      const deltaX = startX - e.clientX; // Dragging left increases width
      const newWidth = Math.max(300, Math.min(800, startWidth + deltaX));
      sidePanel.style.width = newWidth + 'px';
    });

    document.addEventListener('mouseup', () => {
      if (isResizing) {
        isResizing = false;
        resizeHandle.classList.remove('dragging');
        document.body.style.cursor = '';
        document.body.style.userSelect = '';

        // Save width to localStorage
        localStorage.setItem('sidePanelWidth', sidePanel.offsetWidth);
      }
    });

    // --- Mobile: Auto-open Isla's chat on load ---
    if (window.innerWidth <= 768) {
      // On mobile, open Isla's chat by default
      setTimeout(() => {
        const islaAgent = document.querySelector('.agent.isla');
        if (islaAgent) {
          islaAgent.click();
        }
      }, 500);
    }

    // ============================================================
    // PWA SERVICE WORKER & PUSH NOTIFICATIONS
    // ============================================================

    // VAPID Public Key (from config)
    const VAPID_PUBLIC_KEY = 'BDN_XpBCR60xryFLfXVewyeWk5VwOOnKzUHx2k1ocUPpOIFixyalNdiuvOvVuT6PLEHGHIZ1SF-6VlImmcyC9nQ';

    // Helper: Convert VAPID key to Uint8Array
    function urlBase64ToUint8Array(base64String) {
      const padding = '='.repeat((4 - base64String.length % 4) % 4);
      const base64 = (base64String + padding)
        .replace(/-/g, '+')
        .replace(/_/g, '/');
      const rawData = window.atob(base64);
      const outputArray = new Uint8Array(rawData.length);
      for (let i = 0; i < rawData.length; ++i) {
        outputArray[i] = rawData.charCodeAt(i);
      }
      return outputArray;
    }

    // Check if PWA features are supported
    if ('serviceWorker' in navigator && 'PushManager' in window) {
      console.log('[PWA] Service worker and push notifications supported');
      
      // Register service worker
      navigator.serviceWorker.register('/service-worker.js')
        .then(async (registration) => {
          console.log('[PWA] Service Worker registered:', registration.scope);
          
          // Check if already subscribed
          const existingSubscription = await registration.pushManager.getSubscription();
          
          if (existingSubscription) {
            console.log('[PWA] Already subscribed to push notifications');
            return;
          }
          
          // Wait a bit before requesting permission (better UX)
          setTimeout(async () => {
            try {
              // Request notification permission
              const permission = await Notification.requestPermission();
              
              if (permission === 'granted') {
                console.log('[PWA] Notification permission granted');
                
                // Subscribe to push notifications
                const subscription = await registration.pushManager.subscribe({
                  userVisibleOnly: true,
                  applicationServerKey: urlBase64ToUint8Array(VAPID_PUBLIC_KEY)
                });
                
                console.log('[PWA] Push subscription created:', subscription.endpoint);
                
                // Send subscription to backend
                const response = await fetch('/api/push/subscribe', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify(subscription)
                });
                
                const result = await response.json();
                
                if (result.ok) {
                  console.log('[PWA] âœ… Push notifications enabled');
                  showToast('Push notifications enabled! ğŸ””', 'success');
                } else {
                  console.error('[PWA] Failed to register subscription:', result.error);
                  showToast('Failed to enable notifications', 'error');
                }
              } else {
                console.log('[PWA] Notification permission denied');
              }
            } catch (err) {
              console.error('[PWA] Notification setup failed:', err);
            }
          }, 2000); // Wait 2 seconds after page load
        })
        .catch((err) => {
          console.error('[PWA] Service Worker registration failed:', err);
        });
      
      // Listen for messages from service worker (e.g., notification clicks)
      navigator.serviceWorker.addEventListener('message', (event) => {
        console.log('[PWA] Message from service worker:', event.data);
        
        // Handle agent switch from notification click
        if (event.data && event.data.type === 'SWITCH_AGENT') {
          const agentKey = event.data.agentKey;
          const agentElement = document.querySelector(`.agent.${agentKey}`);
          
          if (agentElement) {
            agentElement.click();
          }
        }
      });
      
      // Handle "beforeinstallprompt" event for PWA installation
      let deferredPrompt;
      window.addEventListener('beforeinstallprompt', (e) => {
        e.preventDefault();
        deferredPrompt = e;
        
        console.log('[PWA] Install prompt available');
        
        // Show custom "Install App" button (if you want to add UI for this)
        // For now, users can install via browser menu
      });
      
      // Track installation
      window.addEventListener('appinstalled', () => {
        console.log('[PWA] App installed successfully');
        showToast('Office installed! ğŸ“±', 'success');
        deferredPrompt = null;
      });
      
    } else {
      console.warn('[PWA] Service worker or push notifications not supported on this browser');
    }

    // ============================================================
    // NOTIFICATION SETTINGS MODAL
    // ============================================================

    const settingsBtn = document.getElementById('settingsBtn');
    const settingsModal = document.getElementById('settingsModal');
    const settingsClose = document.getElementById('settingsClose');
    const notificationsEnabled = document.getElementById('notificationsEnabled');
    const agentTogglesContainer = document.getElementById('agentToggles');
    const testNotificationBtn = document.getElementById('testNotificationBtn');
    const pushStatusText = document.getElementById('pushStatusText');

    // All agents list
    const allAgents = [
      { key: 'isla', emoji: 'ğŸï¸', name: 'Isla' },
      { key: 'marcus', emoji: 'ğŸ”§', name: 'Marcus' },
      { key: 'harper', emoji: 'ğŸ”', name: 'Harper' },
      { key: 'eli', emoji: 'ğŸ—ï¸', name: 'Eli' },
      { key: 'sage', emoji: 'ğŸ”¬', name: 'Sage' },
      { key: 'julie', emoji: 'ğŸ“¢', name: 'Julie' },
      { key: 'dash', emoji: 'ğŸƒ', name: 'Dash' },
      { key: 'remy', emoji: 'ğŸ‘¨â€ğŸ³', name: 'Remy' },
      { key: 'lena', emoji: 'ğŸ’ª', name: 'Lena' },
      { key: 'val', emoji: 'ğŸ’°', name: 'Val' },
      { key: 'atlas', emoji: 'ğŸ—ºï¸', name: 'Atlas' },
      { key: 'nova', emoji: 'ğŸŒŸ', name: 'Nova' }
    ];

    // Load notification settings from localStorage
    function loadNotificationSettings() {
      const settings = localStorage.getItem('notificationSettings');
      if (settings) {
        return JSON.parse(settings);
      }
      // Default: all enabled
      return {
        enabled: true,
        agents: allAgents.map(a => a.key)
      };
    }

    // Save notification settings to localStorage
    function saveNotificationSettings(settings) {
      localStorage.setItem('notificationSettings', JSON.stringify(settings));
    }

    // Initialize settings
    let notificationSettings = loadNotificationSettings();

    // Populate agent toggles
    function renderAgentToggles() {
      agentTogglesContainer.innerHTML = allAgents.map(agent => `
        <label class="agent-toggle">
          <input 
            type="checkbox" 
            data-agent="${agent.key}" 
            ${notificationSettings.agents.includes(agent.key) ? 'checked' : ''}
          >
          <span class="agent-toggle-label">
            <span class="agent-toggle-emoji">${agent.emoji}</span>
            <span>${agent.name}</span>
          </span>
        </label>
      `).join('');

      // Add event listeners
      agentTogglesContainer.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
        checkbox.addEventListener('change', (e) => {
          const agentKey = e.target.dataset.agent;
          if (e.target.checked) {
            if (!notificationSettings.agents.includes(agentKey)) {
              notificationSettings.agents.push(agentKey);
            }
          } else {
            notificationSettings.agents = notificationSettings.agents.filter(k => k !== agentKey);
          }
          saveNotificationSettings(notificationSettings);
        });
      });
    }

    // Update push status
    async function updatePushStatus() {
      try {
        const response = await fetch('/api/push/status');
        const status = await response.json();
        
        if (status.ok && status.enabled) {
          pushStatusText.innerHTML = `
            âœ… Push notifications configured<br>
            ${status.subscribers} device(s) subscribed
          `;
          pushStatusText.style.color = '#4ade80';
        } else {
          pushStatusText.innerHTML = 'âš ï¸ Push notifications not configured';
          pushStatusText.style.color = '#fbbf24';
        }
      } catch (err) {
        pushStatusText.innerHTML = 'âŒ Failed to check status';
        pushStatusText.style.color = '#f87171';
      }
    }

    // Open settings modal
    settingsBtn.addEventListener('click', () => {
      settingsModal.classList.remove('hidden');
      notificationsEnabled.checked = notificationSettings.enabled;
      renderAgentToggles();
      updatePushStatus();
    });

    // Close settings modal
    settingsClose.addEventListener('click', () => {
      settingsModal.classList.add('hidden');
    });

    // Click outside to close
    settingsModal.addEventListener('click', (e) => {
      if (e.target === settingsModal) {
        settingsModal.classList.add('hidden');
      }
    });

    // Toggle notifications on/off
    notificationsEnabled.addEventListener('change', (e) => {
      notificationSettings.enabled = e.target.checked;
      saveNotificationSettings(notificationSettings);
      
      if (e.target.checked) {
        showToast('Notifications enabled', 'success');
      } else {
        showToast('Notifications disabled', 'info');
      }
    });

    // Test notification button
    testNotificationBtn.addEventListener('click', async () => {
      try {
        testNotificationBtn.disabled = true;
        testNotificationBtn.textContent = 'Sending...';
        
        const response = await fetch('/api/push/test', { method: 'POST' });
        const result = await response.json();
        
        if (result.ok) {
          showToast('Test notification sent! ğŸ””', 'success');
        } else {
          showToast('Failed to send test notification', 'error');
        }
      } catch (err) {
        showToast('Error sending test notification', 'error');
      } finally {
        testNotificationBtn.disabled = false;
        testNotificationBtn.textContent = 'ğŸ”” Send Test Notification';
      }
    });

    // Initialize
    renderAgentToggles();
  </script>
</body>
</html>
