<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Office - Team HQ</title>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/apexcharts@3.45.1/dist/apexcharts.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      color: #fff;
      display: flex;
      overflow: hidden;
    }

    /* Mobile menu button */
    .mobile-menu-btn {
      display: none;
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 1001;
      background: rgba(14, 165, 233, 0.9);
      border: none;
      border-radius: 8px;
      width: 44px;
      height: 44px;
      color: #fff;
      font-size: 1.2rem;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .mobile-menu-btn:active {
      transform: scale(0.95);
    }

    /* Overlay backdrop */
    .panel-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.6);
      z-index: 999;
    }

    .panel-overlay.active {
      display: block;
    }

    /* Main office area */
    .office-container {
      flex: 1;
      padding: 20px;
      padding-left: 340px;
      overflow: auto;
    }

    h1 {
      text-align: center;
      margin-bottom: 20px;
      font-weight: 300;
      font-size: 1.5rem;
      color: #888;
    }

    .office {
      max-width: 800px;
      margin: 0 auto;
      background: #0f0f1a;
      border-radius: 20px;
      padding: 30px;
      position: relative;
      min-height: 600px;
      border: 1px solid #333;
    }

    .zone {
      position: absolute;
      border-radius: 12px;
      padding: 15px;
      background: rgba(255,255,255,0.03);
      border: 1px dashed rgba(255,255,255,0.1);
    }

    .zone-label {
      font-size: 0.7rem;
      color: #555;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 10px;
    }

    /* Zones */
    .desks { top: 20px; left: 20px; width: 500px; height: 280px; }
    .conference { top: 320px; left: 20px; width: 500px; height: 150px; background: rgba(99, 102, 241, 0.05); }
    .kitchen { top: 20px; right: 20px; width: 220px; height: 200px; background: rgba(251, 146, 60, 0.05); }
    .finance-corner { top: 240px; right: 20px; width: 220px; height: 120px; background: rgba(34, 197, 94, 0.05); }
    .adventure-corner { bottom: 100px; right: 20px; width: 220px; height: 120px; background: rgba(139, 92, 246, 0.05); }
    .isla-desk { bottom: 20px; left: 50%; transform: translateX(-50%); width: 180px; height: 80px; background: rgba(14, 165, 233, 0.1); border: 1px solid rgba(14, 165, 233, 0.3); }

    /* Agents */
    .agent {
      position: absolute;
      display: flex;
      flex-direction: column;
      align-items: center;
      cursor: pointer;
      transition: transform 0.2s, filter 0.2s;
    }

    .agent:hover {
      transform: scale(1.1);
      transition: transform 0.2s ease, top 1s ease-out, left 1s ease-out, right 1s ease-out, bottom 1s ease-out;
    }

    .agent.selected {
      transform: scale(1.15);
      filter: drop-shadow(0 0 10px rgba(14, 165, 233, 0.5));
    }

    .avatar {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      position: relative;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }

    .status-dot {
      position: absolute;
      bottom: 2px;
      right: 2px;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 2px solid #0f0f1a;
    }

    .status-working { background: #22c55e; }
    .status-idle { background: #eab308; }
    .status-meeting { background: #8b5cf6; }
    .status-thinking { background: #3b82f6; }

    .unread-badge {
      position: absolute;
      top: -4px;
      right: -4px;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #f43f5e;
      border: 2px solid #0f0f1a;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 0.65rem;
      font-weight: 700;
      color: #fff;
      z-index: 10;
      animation: pulse-badge 2s infinite;
    }

    .agent.has-unread .unread-badge {
      display: flex;
    }

    @keyframes pulse-badge {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    @keyframes slideIn {
      from {
        transform: translateX(400px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes slideOut {
      from {
        transform: translateX(0);
        opacity: 1;
      }
      to {
        transform: translateX(400px);
        opacity: 0;
      }
    }

    /* Responsive Design - Tablet & Mobile */
    @media (max-width: 1200px) {
      /* Tablet: Show mobile menu, keep most desktop layout */
      .mobile-menu-btn {
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .left-info-panel {
        transform: translateX(-100%);
        transition: transform 0.3s ease;
        z-index: 1000;
      }

      .left-info-panel.mobile-visible {
        transform: translateX(0);
      }

      .office-container {
        padding-left: 20px;
      }

      .side-panel {
        position: fixed;
        right: 0;
        top: 0;
        bottom: 0;
        width: 100%;
        max-width: 500px;
        border-radius: 0;
        z-index: 1001;
      }
    }

    @media (max-width: 768px) {
      /* Mobile: Chat-first interface */
      body {
        overflow: hidden;
      }

      /* Hide office view on mobile, show chat instead */
      .office-container {
        display: none;
      }

      /* Side panel becomes full-screen chat */
      .side-panel {
        position: fixed !important;
        left: 0;
        right: 0;
        top: 0;
        bottom: 60px; /* Space for bottom nav */
        height: auto !important; /* Override 100vh */
        max-height: none !important; /* Allow it to use available space */
        width: 100%;
        max-width: 100%;
        border-radius: 0;
        transform: translateX(0) !important;
        z-index: 900; /* Below left panel so hamburger menu appears on top */
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .side-panel.hidden {
        display: none;
      }

      /* Remove resize handle on mobile */
      .resize-handle {
        display: none;
      }

      /* Mobile menu button in top-left - always on top */
      .mobile-menu-btn {
        display: flex !important;
        align-items: center;
        justify-content: center;
        top: 10px;
        left: 10px;
        width: 40px;
        height: 40px;
        z-index: 1200; /* Above everything so it's always clickable */
        background: rgba(14, 165, 233, 0.95);
        border: none;
        border-radius: 8px;
        color: #fff;
        font-size: 1.2rem;
        cursor: pointer;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      }

      /* Left info panel full screen overlay - slides over chat */
      .left-info-panel {
        position: fixed;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        width: 100%;
        max-width: 100%;
        border-radius: 0;
        padding: 60px 20px 20px;
        overflow-y: auto;
        z-index: 1100; /* Above chat panel (900) and overlay (1000) */
        transform: translateX(-100%);
        transition: transform 0.3s ease;
        background: rgba(15, 15, 26, 0.98); /* Slightly more opaque on mobile */
      }

      .left-info-panel.mobile-visible {
        transform: translateX(0);
      }

      .left-info-panel.mobile-hidden {
        transform: translateX(-100%);
      }

      /* Panel overlay darker on mobile - appears between chat and left panel */
      .panel-overlay {
        z-index: 1000;
        background: rgba(0, 0, 0, 0.7);
      }

      /* Adjust panel header for mobile */
      .panel-header {
        padding: 12px 15px;
      }

      .panel-header h2 {
        font-size: 1.1rem;
      }

      /* Bigger touch targets for tabs */
      .panel-tab {
        padding: 12px 16px;
        font-size: 0.9rem;
      }

      /* Chat input optimized for mobile keyboard */
      .chat-input-container {
        padding: 12px !important;
        flex-shrink: 0; /* Don't let it shrink */
        display: flex !important;
        gap: 10px;
        align-items: flex-end;
        background: #0f0f1a; /* Ensure it's visible */
        border-top: 1px solid #333 !important;
      }

      #chatInput {
        font-size: 16px !important; /* Prevents iOS zoom */
        padding: 12px !important;
        min-height: 44px; /* iOS recommended tap target */
      }

      #chatSend {
        padding: 12px 24px !important;
        font-size: 0.95rem;
        min-height: 44px; /* iOS recommended tap target */
      }

      /* Ensure tab-pane fills available space */
      #tab-chat {
        display: flex !important;
        flex-direction: column !important;
        height: 100%;
        overflow: hidden;
      }

      /* Chat messages should scroll, input should stay at bottom */
      #chatMessages {
        flex: 1 !important;
        overflow-y: auto !important;
        min-height: 0;
      }

      /* Message bubbles more compact */
      .message-bubble {
        max-width: 85%;
        font-size: 0.9rem;
      }
    }

    /* Bottom navigation bar for mobile */
    @media (max-width: 768px) {
      .mobile-bottom-nav {
        display: flex !important;
      }
    }

    .mobile-bottom-nav {
      display: none;
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 60px;
      background: #1e1e2e;
      border-top: 1px solid #333;
      z-index: 1002;
      overflow-x: auto;
      overflow-y: hidden;
      white-space: nowrap;
      scrollbar-width: none; /* Firefox */
    }

    .mobile-bottom-nav::-webkit-scrollbar {
      display: none; /* Chrome/Safari */
    }

    .mobile-nav-item {
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-width: 60px;
      padding: 8px 12px;
      cursor: pointer;
      transition: background 0.2s;
      text-decoration: none;
      border: none;
      background: none;
      color: #888;
    }

    .mobile-nav-item:active {
      background: rgba(14, 165, 233, 0.1);
    }

    .mobile-nav-item.active {
      color: #0ea5e9;
      background: rgba(14, 165, 233, 0.1);
    }

    .mobile-nav-emoji {
      font-size: 1.5rem;
      margin-bottom: 2px;
    }

    .mobile-nav-name {
      font-size: 0.65rem;
      font-weight: 500;
    }

    .mobile-nav-unread {
      position: absolute;
      top: 4px;
      right: 8px;
      background: #ef4444;
      color: white;
      border-radius: 10px;
      padding: 2px 6px;
      font-size: 0.65rem;
      font-weight: 600;
    }

    .agent-name {
      font-size: 0.75rem;
      margin-top: 5px;
      color: #ccc;
      font-weight: 600;
    }

    .agent-role {
      font-size: 0.6rem;
      color: #888;
      margin-top: 1px;
    }

    .agent-task {
      font-size: 0.55rem;
      color: #555;
      max-width: 90px;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      margin-top: 2px;
    }

    /* Agent colors */
    .isla .avatar { background: linear-gradient(135deg, #0ea5e9, #06b6d4); }
    .marcus .avatar { background: linear-gradient(135deg, #6366f1, #8b5cf6); }
    .harper .avatar { background: linear-gradient(135deg, #f43f5e, #ec4899); }
    .sage .avatar { background: linear-gradient(135deg, #8b5cf6, #a855f7); }
    .eli .avatar { background: linear-gradient(135deg, #64748b, #475569); }
    .julie .avatar { background: linear-gradient(135deg, #ec4899, #f472b6); }
    .remy .avatar { background: linear-gradient(135deg, #fb923c, #f97316); }
    .lena .avatar { background: linear-gradient(135deg, #22c55e, #16a34a); }
    .val .avatar { background: linear-gradient(135deg, #22d3ee, #06b6d4); }
    .atlas .avatar { background: linear-gradient(135deg, #8b5cf6, #7c3aed); }
    .dash .avatar { background: linear-gradient(135deg, #a78bfa, #c084fc); }

    /* Positions - using CSS custom properties for animation */
    .agent {
      transition: top 1s ease-out, left 1s ease-out, right 1s ease-out, bottom 1s ease-out, transform 1s ease-out;
    }

    .marcus { top: 50px; left: 40px; }
    .harper { top: 50px; left: 160px; }
    .eli { top: 50px; left: 280px; }
    .sage { top: 50px; left: 400px; }
    .dash { top: 170px; left: 40px; }
    .julie { top: 170px; left: 220px; }

    .remy { top: 60px; right: 100px; }
    .lena { top: 140px; right: 100px; }

    .val { top: 270px; right: 100px; }
    .atlas { bottom: 130px; right: 130px; }

    .isla { bottom: 35px; left: 50%; transform: translateX(-50%); }
    .isla:hover { transform: translateX(-50%) scale(1.1); transition: transform 0.2s ease; }
    .isla.selected { transform: translateX(-50%) scale(1.15); }

    /* Conference table */
    .conference-table {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 200px;
      height: 60px;
      background: rgba(99, 102, 241, 0.2);
      border-radius: 30px;
      border: 1px solid rgba(99, 102, 241, 0.3);
    }

    /* Legend */
    .legend {
      display: flex;
      gap: 20px;
      justify-content: center;
      margin-top: 20px;
      flex-wrap: wrap;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.75rem;
      color: #666;
    }

    .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }

    /* Side Panel */
    .side-panel {
      width: 400px;
      min-width: 300px;
      max-width: 800px;
      height: 100vh;
      max-height: 100vh;
      background: #0f0f1a;
      border-left: 1px solid #333;
      display: flex;
      flex-direction: column;
      transition: transform 0.3s, width 0.3s, min-width 0.3s;
      overflow: hidden;
      position: relative;
    }

    .side-panel.hidden {
      transform: translateX(100%);
      width: 0;
      min-width: 0;
      overflow: hidden;
    }

    .resize-handle {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      cursor: ew-resize;
      background: transparent;
      z-index: 1000;
      transition: background 0.2s;
    }

    .resize-handle:hover,
    .resize-handle.dragging {
      background: rgba(14, 165, 233, 0.3);
    }

    .resize-handle::before {
      content: '';
      position: absolute;
      left: 2px;
      top: 50%;
      transform: translateY(-50%);
      width: 2px;
      height: 40px;
      background: #333;
      border-radius: 1px;
    }

    .resize-handle.dragging::before {
      background: #0ea5e9;
    }

    .panel-header {
      padding: 20px;
      border-bottom: 1px solid #333;
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .panel-avatar {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
    }

    .panel-info h2 {
      font-size: 1.1rem;
      font-weight: 600;
    }

    .panel-info .role {
      font-size: 0.8rem;
      color: #888;
    }

    .panel-close {
      margin-left: auto;
      background: none;
      border: none;
      color: #666;
      font-size: 1.5rem;
      cursor: pointer;
    }

    .panel-close:hover { color: #fff; }

    /* Tabs */
    .panel-tabs {
      display: flex;
      border-bottom: 1px solid #333;
    }

    .panel-tab {
      flex: 1;
      padding: 12px;
      text-align: center;
      font-size: 0.8rem;
      color: #666;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      transition: all 0.2s;
    }

    .panel-tab:hover { color: #aaa; }
    .panel-tab.active {
      color: #0ea5e9;
      border-bottom-color: #0ea5e9;
    }

    /* Tab Content */
    .tab-content {
      flex: 1;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .tab-pane {
      display: none;
      flex: 1;
      overflow: hidden;
      padding: 0;
      min-height: 0;
    }

    .tab-pane.active { display: flex; flex-direction: column; }

    .tab-pane#tab-memory, .tab-pane#tab-status, .tab-pane#tab-files {
      padding: 15px;
      overflow-y: auto;
    }

    /* Chat - Message Bubbles */
    .chat-messages {
      flex: 1;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 15px;
      background: #16213e;
    }

    .message-bubble {
      display: flex;
      gap: 8px;
      max-width: 75%;
      align-items: flex-end;
      margin-bottom: 4px;
    }

    .message-bubble.them {
      align-self: flex-start;
    }

    .message-bubble.you {
      align-self: flex-end;
      flex-direction: row-reverse;
    }

    .bubble-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      flex-shrink: 0;
    }

    .bubble-avatar.bot {
      background: linear-gradient(135deg, #0ea5e9, #06b6d4);
    }

    .bubble-avatar.jeremy {
      background: linear-gradient(135deg, #f43f5e, #ec4899);
    }

    .bubble-content {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .bubble-text {
      padding: 10px 14px;
      border-radius: 16px;
      font-size: 0.9rem;
      line-height: 1.4;
      word-wrap: break-word;
      white-space: pre-wrap;
    }

    .message-bubble.them .bubble-text {
      background: #2a2a3e;
      color: #dcddde;
      border-bottom-left-radius: 4px;
    }

    .message-bubble.you .bubble-text {
      background: linear-gradient(135deg, #0ea5e9, #0284c7);
      color: #fff;
      border-bottom-right-radius: 4px;
    }

    .bubble-time {
      font-size: 0.7rem;
      color: #72767d;
      padding: 0 8px;
    }

    .message-bubble.you .bubble-time {
      text-align: right;
    }

    .bubble-text code {
      background: rgba(0, 0, 0, 0.3);
      padding: 2px 5px;
      border-radius: 3px;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 0.85em;
    }

    .bubble-text pre {
      background: rgba(0, 0, 0, 0.3);
      padding: 8px;
      border-radius: 4px;
      overflow-x: auto;
      margin: 6px 0;
    }

    .bubble-text pre code {
      background: none;
      padding: 0;
    }

    .bubble-text strong {
      font-weight: 700;
    }

    .bubble-text em {
      font-style: italic;
    }

    .bubble-text a {
      color: inherit;
      text-decoration: underline;
      opacity: 0.9;
    }

    .bubble-text a:hover {
      opacity: 1;
    }

    .bubble-text h1, .bubble-text h2, .bubble-text h3,
    .bubble-text h4, .bubble-text h5, .bubble-text h6 {
      font-weight: 700;
      margin: 8px 0 4px 0;
      line-height: 1.3;
    }

    .bubble-text h1 { font-size: 1.4em; }
    .bubble-text h2 { font-size: 1.3em; }
    .bubble-text h3 { font-size: 1.2em; }
    .bubble-text h4 { font-size: 1.1em; }
    .bubble-text h5 { font-size: 1em; }
    .bubble-text h6 { font-size: 0.95em; }

    .bubble-text p {
      margin: 4px 0;
    }

    .bubble-text ul, .bubble-text ol {
      margin: 4px 0;
      padding-left: 20px;
    }

    .bubble-text li {
      margin: 2px 0;
    }

    .bubble-text blockquote {
      border-left: 3px solid rgba(255, 255, 255, 0.3);
      margin: 6px 0;
      padding: 4px 10px;
      background: rgba(0, 0, 0, 0.2);
      font-style: italic;
    }

    .bubble-text hr {
      border: none;
      border-top: 1px solid rgba(255, 255, 255, 0.2);
      margin: 8px 0;
    }

    /* Chart container */
    .chart-container {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      padding: 15px;
      margin: 10px 0;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .chart-title {
      font-size: 0.85rem;
      font-weight: 600;
      color: #e0e0e0;
      margin-bottom: 10px;
      text-align: center;
    }

    .chart-wrapper {
      min-height: 200px;
    }

    .bubble-text table {
      border-collapse: collapse;
      margin: 6px 0;
      font-size: 0.9em;
    }

    .bubble-text th {
      background: rgba(0, 0, 0, 0.3);
      padding: 4px 8px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      font-weight: 600;
    }

    .bubble-text td {
      padding: 4px 8px;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .typing-indicator {
      color: #888;
      font-style: italic;
    }

    .chat-input-container {
      display: flex;
      gap: 10px;
      padding-top: 10px;
      border-top: 1px solid #333;
    }

    .chat-input {
      flex: 1;
      background: #1e1e2e;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 10px 12px;
      color: #fff;
      font-size: 0.85rem;
    }

    .chat-input:focus {
      outline: none;
      border-color: #0ea5e9;
    }

    .chat-send {
      background: #0ea5e9;
      border: none;
      border-radius: 8px;
      padding: 10px 16px;
      color: #fff;
      cursor: pointer;
      font-weight: 500;
    }

    .chat-send:hover { background: #0284c7; }

    /* Memory */
    .memory-section {
      margin-bottom: 20px;
    }

    .memory-section h3 {
      font-size: 0.75rem;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 10px;
    }

    .memory-item {
      background: #1e1e2e;
      border-radius: 8px;
      padding: 10px 12px;
      margin-bottom: 8px;
      font-size: 0.8rem;
      color: #aaa;
    }

    .memory-item .source {
      font-size: 0.65rem;
      color: #555;
      margin-top: 5px;
    }

    /* Status */
    .status-section {
      margin-bottom: 20px;
    }

    .status-section h3 {
      font-size: 0.75rem;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 10px;
    }

    .status-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .status-card {
      background: #1e1e2e;
      border-radius: 8px;
      padding: 12px;
    }

    .status-card .label {
      font-size: 0.65rem;
      color: #555;
      text-transform: uppercase;
    }

    .status-card .value {
      font-size: 1rem;
      font-weight: 600;
      margin-top: 4px;
    }

    .status-card .value.green { color: #22c55e; }
    .status-card .value.yellow { color: #eab308; }
    .status-card .value.blue { color: #3b82f6; }

    .recent-activity {
      margin-top: 20px;
    }

    .activity-item {
      display: flex;
      gap: 10px;
      padding: 8px 0;
      border-bottom: 1px solid #222;
      font-size: 0.8rem;
    }

    .activity-time {
      color: #555;
      font-size: 0.7rem;
      white-space: nowrap;
    }

    .activity-text {
      color: #aaa;
    }

    /* Quote */
    .agent-quote {
      background: #1e1e2e;
      border-radius: 8px;
      padding: 15px;
      margin-top: auto;
      font-style: italic;
      color: #666;
      font-size: 0.8rem;
      border-left: 3px solid #333;
    }

    /* Files Tab */
    .files-section {
      height: 100%;
      display: flex;
      flex-direction: column;
    }
    .files-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    .files-header h3 {
      font-size: 0.9rem;
      color: #fff;
      margin: 0;
    }
    .refresh-btn {
      background: transparent;
      border: 1px solid #444;
      color: #888;
      padding: 4px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
    }
    .refresh-btn:hover {
      background: #333;
      color: #fff;
    }
    .files-list {
      flex: 1;
      overflow-y: auto;
    }
    .file-item {
      background: #1e1e2e;
      border-radius: 8px;
      padding: 12px 15px;
      margin-bottom: 10px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .file-item:hover {
      background: #2a2a3e;
    }
    .file-item .file-name {
      font-weight: 600;
      color: #fff;
      font-size: 0.9rem;
      margin-bottom: 4px;
    }
    .file-item .file-meta {
      font-size: 0.75rem;
      color: #666;
      display: flex;
      gap: 12px;
    }
    .file-item .file-preview {
      font-size: 0.8rem;
      color: #888;
      margin-top: 8px;
      line-height: 1.4;
      max-height: 60px;
      overflow: hidden;
    }

    /* Folder structure styles */
    .folder-item {
      margin-bottom: 4px;
    }
    .folder-header {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      cursor: pointer;
      border-radius: 6px;
      transition: background 0.2s;
    }
    .folder-header:hover {
      background: #2a2a3e;
    }
    .folder-toggle {
      font-size: 0.9rem;
      user-select: none;
      transition: transform 0.2s;
    }
    .folder-item.collapsed .folder-toggle {
      transform: rotate(-90deg);
    }
    .folder-name {
      font-weight: 600;
      color: #0ea5e9;
      font-size: 0.85rem;
    }
    .folder-children {
      transition: max-height 0.3s ease-out;
      overflow: hidden;
    }
    .folder-item.collapsed .folder-children {
      display: none;
    }

    .file-viewer {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.9);
      z-index: 1000;
      display: flex;
      flex-direction: column;
      padding: 20px;
    }
    .file-viewer-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-bottom: 15px;
      border-bottom: 1px solid #333;
      margin-bottom: 15px;
    }
    .file-viewer-header h2 {
      margin: 0;
      color: #fff;
    }
    .file-viewer-close {
      background: #ed4245;
      border: none;
      color: #fff;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
    }
    .file-viewer-content {
      flex: 1;
      overflow-y: auto;
      background: #1e1e2e;
      border-radius: 8px;
      padding: 20px;
      font-family: 'Monaco', 'Consolas', monospace;
      font-size: 0.9rem;
      line-height: 1.5;
      color: #dcddde;
      white-space: pre-wrap;
    }
    .file-viewer-content.markdown-view {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      white-space: normal;
      max-width: 900px;
      margin: 0 auto;
    }

    /* Markdown styling */
    .markdown-view h1 {
      font-size: 2rem;
      font-weight: 700;
      color: #fff;
      margin: 1.5rem 0 1rem 0;
      padding-bottom: 0.3rem;
      border-bottom: 2px solid #444;
    }
    .markdown-view h2 {
      font-size: 1.5rem;
      font-weight: 700;
      color: #fff;
      margin: 1.5rem 0 1rem 0;
      padding-bottom: 0.3rem;
      border-bottom: 1px solid #333;
    }
    .markdown-view h3 {
      font-size: 1.25rem;
      font-weight: 600;
      color: #e0e0e0;
      margin: 1.25rem 0 0.75rem 0;
    }
    .markdown-view h4 {
      font-size: 1.1rem;
      font-weight: 600;
      color: #d0d0d0;
      margin: 1rem 0 0.5rem 0;
    }
    .markdown-view h5 {
      font-size: 1rem;
      font-weight: 600;
      color: #c0c0c0;
      margin: 0.75rem 0 0.5rem 0;
    }
    .markdown-view h6 {
      font-size: 0.9rem;
      font-weight: 600;
      color: #b0b0b0;
      margin: 0.75rem 0 0.5rem 0;
    }
    .markdown-view p {
      margin: 0.75rem 0;
      line-height: 1.6;
      color: #dcddde;
    }
    .markdown-view ul, .markdown-view ol {
      margin: 0.75rem 0;
      padding-left: 2rem;
      color: #dcddde;
    }
    .markdown-view li {
      margin: 0.25rem 0;
      line-height: 1.6;
    }
    .markdown-view ul ul, .markdown-view ol ol, .markdown-view ul ol, .markdown-view ol ul {
      margin: 0.25rem 0;
    }
    .markdown-view code {
      background: #2a2a3e;
      padding: 0.2em 0.4em;
      border-radius: 3px;
      font-family: 'Monaco', 'Consolas', monospace;
      font-size: 0.85em;
      color: #f0f0f0;
    }
    .markdown-view pre {
      background: #2a2a3e;
      border: 1px solid #3a3a4e;
      border-radius: 6px;
      padding: 1rem;
      overflow-x: auto;
      margin: 1rem 0;
    }
    .markdown-view pre code {
      background: none;
      padding: 0;
      border-radius: 0;
      font-size: 0.9em;
      line-height: 1.5;
      color: #f0f0f0;
    }
    .markdown-view blockquote {
      border-left: 4px solid #0ea5e9;
      margin: 1rem 0;
      padding: 0.5rem 1rem;
      background: rgba(14, 165, 233, 0.1);
      color: #b0b0b0;
    }
    .markdown-view blockquote p {
      margin: 0.5rem 0;
    }
    .markdown-view a {
      color: #0ea5e9;
      text-decoration: none;
    }
    .markdown-view a:hover {
      text-decoration: underline;
    }
    .markdown-view table {
      border-collapse: collapse;
      width: 100%;
      margin: 1rem 0;
    }
    .markdown-view th {
      background: #2a2a3e;
      border: 1px solid #444;
      padding: 0.75rem;
      text-align: left;
      font-weight: 600;
      color: #fff;
    }
    .markdown-view td {
      border: 1px solid #333;
      padding: 0.75rem;
      color: #dcddde;
    }
    .markdown-view tr:nth-child(even) {
      background: rgba(255, 255, 255, 0.02);
    }
    .markdown-view hr {
      border: none;
      border-top: 1px solid #444;
      margin: 2rem 0;
    }
    .markdown-view strong {
      font-weight: 700;
      color: #fff;
    }
    .markdown-view em {
      font-style: italic;
      color: #e0e0e0;
    }
    .markdown-view img {
      max-width: 100%;
      height: auto;
      border-radius: 4px;
      margin: 1rem 0;
    }
    .no-files {
      color: #666;
      text-align: center;
      padding: 40px 20px;
    }

    /* Interaction lines animation */
    @keyframes pulse-line {
      0%, 100% { opacity: 0.4; }
      50% { opacity: 1; }
    }

    /* Left Info Panel */
    .left-info-panel {
      position: fixed;
      left: 20px;
      top: 20px;
      bottom: 20px;
      width: 300px;
      background: rgba(15, 15, 26, 0.95);
      border: 1px solid #333;
      border-radius: 12px;
      padding: 15px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 20px;
      overflow-y: auto;
      transition: transform 0.3s ease;
    }

    .left-info-panel.mobile-hidden {
      transform: translateX(-340px);
    }

    /* Left Panel Tabs */
    .left-panel-tabs {
      display: flex;
      gap: 4px;
      margin-bottom: 15px;
      border-bottom: 1px solid #333;
      padding-bottom: 10px;
      flex-shrink: 0;
    }

    .left-tab {
      flex: 1;
      padding: 8px 4px;
      font-size: 0.7rem;
      color: #666;
      text-align: center;
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.2s ease;
    }

    .left-tab:hover {
      color: #888;
      background: rgba(255, 255, 255, 0.05);
    }

    .left-tab.active {
      color: #8b5cf6;
      background: rgba(139, 92, 246, 0.1);
    }

    .left-tab-content {
      display: none;
      flex: 1;
      overflow-y: auto;
      flex-direction: column;
    }

    .left-tab-content.active {
      display: flex;
    }

    .tab-header {
      font-size: 0.65rem;
      color: #555;
      margin-bottom: 10px;
    }

    .info-section {
      flex-shrink: 0;
    }

    .info-section h3 {
      font-size: 0.75rem;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .info-section .updated {
      font-size: 0.65rem;
      color: #555;
      text-transform: none;
      letter-spacing: 0;
    }

    .interaction-item {
      display: flex;
      flex-direction: column;
      padding: 8px 0;
      border-bottom: 1px solid #222;
      font-size: 0.8rem;
    }

    .interaction-item:last-child {
      border-bottom: none;
    }

    .interaction-agents {
      color: #8b5cf6;
      font-weight: 500;
    }

    .interaction-topic {
      color: #888;
      font-size: 0.75rem;
      margin-top: 2px;
    }

    .no-interactions {
      color: #555;
      font-size: 0.8rem;
      text-align: center;
      padding: 10px;
    }

    .priority-section {
      margin-bottom: 12px;
    }

    .priority-section:last-child {
      margin-bottom: 0;
    }

    .priority-section-title {
      font-size: 0.7rem;
      color: #0ea5e9;
      margin-bottom: 5px;
      font-weight: 600;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .clear-completed-btn {
      font-size: 0.65rem;
      color: #555;
      background: transparent;
      border: 1px solid #333;
      border-radius: 4px;
      padding: 2px 6px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .clear-completed-btn:hover {
      color: #f59e0b;
      border-color: #f59e0b;
    }

    .priority-item {
      font-size: 0.8rem;
      color: #aaa;
      padding: 3px 0;
      padding-left: 12px;
      position: relative;
    }

    .priority-item::before {
      content: '‚Ä¢';
      position: absolute;
      left: 0;
      color: #555;
    }

    .priority-item.blocked {
      color: #f59e0b;
    }

    .priority-item.note {
      color: #888;
      font-size: 0.75rem;
    }

    .standup-item {
      font-size: 0.8rem;
      color: #aaa;
      padding: 5px 0;
      line-height: 1.5;
    }

    .standup-item .agent-emoji {
      display: inline-block;
      width: 20px;
    }

    .standup-item .agent-name {
      font-weight: 600;
      color: #0ea5e9;
    }

    .standup-item .agent-status {
      color: #ccc;
    }

    /* Expanded standup items for tab view */
    .standup-item-expanded {
      padding: 10px 0;
      border-bottom: 1px solid #222;
    }

    .standup-item-expanded:last-child {
      border-bottom: none;
    }

    .standup-agent {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 4px;
    }

    .standup-agent .agent-emoji {
      font-size: 1.1rem;
    }

    .standup-agent .agent-name {
      font-weight: 600;
      color: #8b5cf6;
      font-size: 0.85rem;
    }

    .standup-status {
      color: #aaa;
      font-size: 0.8rem;
      padding-left: 28px;
      line-height: 1.4;
    }

    .action-item {
      font-size: 0.8rem;
      color: #aaa;
      padding: 4px 0;
      padding-left: 25px;
      position: relative;
      cursor: pointer;
      transition: color 0.2s;
    }

    .action-item:hover {
      color: #0ea5e9;
    }

    .action-item input[type="checkbox"] {
      position: absolute;
      left: 0;
      top: 5px;
      cursor: pointer;
      width: 16px;
      height: 16px;
      accent-color: #0ea5e9;
    }

    .action-item.completed {
      color: #555;
      text-decoration: line-through;
    }

    .action-item-text {
      display: inline;
    }

    .section-divider {
      height: 1px;
      background: linear-gradient(90deg, transparent, #333, transparent);
      margin: 15px 0;
    }
  </style>
</head>
<body>
  <!-- Mobile menu button -->
  <button class="mobile-menu-btn" id="mobileMenuBtn">‚ò∞</button>

  <!-- Overlay backdrop -->
  <div class="panel-overlay" id="panelOverlay"></div>

  <div class="office-container">
    <h1 id="officeTime">üè¢ The Office - Loading...</h1>

    <div class="office">
      <!-- Zones -->
      <div class="zone desks">
        <div class="zone-label">Desks</div>
      </div>

      <div class="zone conference">
        <div class="zone-label">Conference Room</div>
        <div class="conference-table"></div>
      </div>

      <div class="zone kitchen">
        <div class="zone-label">Kitchen</div>
      </div>

      <div class="zone finance-corner">
        <div class="zone-label">Finance</div>
      </div>

      <div class="zone adventure-corner">
        <div class="zone-label">Adventure</div>
      </div>

      <div class="zone isla-desk">
        <div class="zone-label" style="text-align: center;">Chief of Staff</div>
      </div>

      <!-- Agents -->
      <div class="agent marcus" data-name="Marcus Chen" data-role="Dev Manager" data-task="Reviewing PR #189" data-quote="Technical debt is just procrastination with a fancier name." data-emoji="üîß">
        <div class="avatar">üîß<div class="status-dot status-working"></div><div class="unread-badge">üí¨</div></div>
        <div class="agent-name">Marcus</div>
        <div class="agent-role">Dev Manager</div>
        <div class="agent-task">Reviewing PR</div>
      </div>

      <div class="agent harper" data-name="Harper Reyes" data-role="QA Manager" data-task="Testing Build 193" data-quote="If you didn't test it, you don't know if it works." data-emoji="üîç">
        <div class="avatar">üîç<div class="status-dot status-working"></div><div class="unread-badge">üí¨</div></div>
        <div class="agent-name">Harper</div>
        <div class="agent-role">QA Manager</div>
        <div class="agent-task">Testing build</div>
      </div>

      <div class="agent eli" data-name="Eli Vasquez" data-role="Chief Architect" data-task="Reviewing DiveStreams patterns" data-quote="The goal isn't elegant code. It's code that survives next quarter." data-emoji="üèóÔ∏è">
        <div class="avatar">üèóÔ∏è<div class="status-dot status-thinking"></div><div class="unread-badge">üí¨</div></div>
        <div class="agent-name">Eli</div>
        <div class="agent-role">Chief Architect</div>
        <div class="agent-task">Architecture review</div>
      </div>

      <div class="agent sage" data-name="Sage Okonkwo" data-role="Researcher" data-task="Competitor analysis" data-quote="The best feature ideas are already in your support tickets." data-emoji="üî≠">
        <div class="avatar">üî≠<div class="status-dot status-idle"></div><div class="unread-badge">üí¨</div></div>
        <div class="agent-name">Sage</div>
        <div class="agent-role">Researcher</div>
        <div class="agent-task">Research</div>
      </div>

      <div class="agent julie" data-name="Julie Marquez" data-role="Marketing Manager" data-task="MHC launch copy" data-quote="People don't buy features. They buy better versions of themselves." data-emoji="üì£">
        <div class="avatar">üì£<div class="status-dot status-working"></div><div class="unread-badge">üí¨</div></div>
        <div class="agent-name">Julie</div>
        <div class="agent-role">Marketing</div>
        <div class="agent-task">Launch copy</div>
      </div>

      <div class="agent dash" data-name="Dash" data-role="Dashboard Engineer" data-task="Building office UI" data-quote="Good dashboards make complexity visible. Great ones make it actionable." data-emoji="üé®">
        <div class="avatar">üé®<div class="status-dot status-working"></div><div class="unread-badge">üí¨</div></div>
        <div class="agent-name">Dash</div>
        <div class="agent-role">Dashboard</div>
        <div class="agent-task">Building UI</div>
      </div>

      <div class="agent remy" data-name="Remy Delacroix" data-role="Chef" data-task="Planning tomorrow's dinner" data-quote="You don't need more recipes. You need a system." data-emoji="üç≥">
        <div class="avatar">üç≥<div class="status-dot status-idle"></div><div class="unread-badge">üí¨</div></div>
        <div class="agent-name">Remy</div>
        <div class="agent-role">Chef</div>
        <div class="agent-task">Meal planning</div>
      </div>

      <div class="agent lena" data-name="Lena Torres" data-role="Gym Coach" data-task="Reviewing week's progress" data-quote="You don't have to feel like it. You just have to show up." data-emoji="üí™">
        <div class="avatar">üí™<div class="status-dot status-idle"></div><div class="unread-badge">üí¨</div></div>
        <div class="agent-name">Lena</div>
        <div class="agent-role">Gym Coach</div>
        <div class="agent-task">Progress review</div>
      </div>

      <div class="agent val" data-name="Val Oduya" data-role="Finance Manager" data-task="Weekly budget prep" data-quote="Wealth isn't about what you make. It's about what you keep." data-emoji="üí∞">
        <div class="avatar">üí∞<div class="status-dot status-working"></div><div class="unread-badge">üí¨</div></div>
        <div class="agent-name">Val</div>
        <div class="agent-role">Finance</div>
        <div class="agent-task">Budget prep</div>
      </div>

      <div class="agent atlas" data-name="Atlas" data-role="Travel Planner" data-task="Ready for trips" data-quote="The best trip is the one you actually take." data-emoji="üó∫Ô∏è">
        <div class="avatar">üó∫Ô∏è<div class="status-dot status-idle"></div><div class="unread-badge">üí¨</div></div>
        <div class="agent-name">Atlas</div>
        <div class="agent-role">Travel</div>
        <div class="agent-task">Ready</div>
      </div>

      <div class="agent isla" data-name="Isla" data-role="Chief of Staff" data-task="Team coordination" data-quote="Sycophants are useless. I'd rather be helpful than agreeable." data-emoji="üèùÔ∏è">
        <div class="avatar">üèùÔ∏è<div class="status-dot status-working"></div><div class="unread-badge">üí¨</div></div>
        <div class="agent-name">Isla</div>
        <div class="agent-role">Chief of Staff</div>
        <div class="agent-task">Coordinating</div>
      </div>
    </div>

    <div class="legend">
      <div class="legend-item"><div class="legend-dot status-working"></div> Working</div>
      <div class="legend-item"><div class="legend-dot status-thinking"></div> Thinking</div>
      <div class="legend-item"><div class="legend-dot status-idle"></div> Idle</div>
      <div class="legend-item"><div class="legend-dot status-meeting"></div> In Meeting</div>
    </div>
  </div>

  <!-- Left Info Panel -->
  <div class="left-info-panel">
    <!-- Tab Navigation -->
    <div class="left-panel-tabs">
      <div class="left-tab active" data-tab="priorities">üéØ Priorities</div>
      <div class="left-tab" data-tab="standup">üìã Standup</div>
      <div class="left-tab" data-tab="interactions">üîó Activity</div>
    </div>

    <!-- Priorities Tab -->
    <div class="left-tab-content active" id="tab-priorities">
      <div class="tab-header">
        <span class="updated" id="prioritiesUpdated"></span>
      </div>
      <div id="prioritiesContent">
        <div class="no-interactions">Loading...</div>
      </div>
    </div>

    <!-- Daily Standup Tab -->
    <div class="left-tab-content" id="tab-standup">
      <div class="tab-header">
        <span class="updated" id="standupDate"></span>
      </div>
      <div id="standupContent">
        <div class="no-interactions">Loading...</div>
      </div>
    </div>

    <!-- Recent Interactions Tab -->
    <div class="left-tab-content" id="tab-interactions">
      <div class="tab-header">Recent Activity</div>
      <div id="interactionFeed">
        <div class="no-interactions">No recent interactions</div>
      </div>
    </div>
  </div>

  <!-- Side Panel -->
  <div class="side-panel hidden" id="sidePanel">
    <div class="resize-handle" id="resizeHandle"></div>
    <div class="panel-header">
      <div class="panel-avatar" id="panelAvatar">üèùÔ∏è</div>
      <div class="panel-info">
        <h2 id="panelName">Isla</h2>
        <div class="role" id="panelRole">Chief of Staff</div>
      </div>
      <button class="panel-close" id="panelClose">√ó</button>
    </div>

    <div class="panel-tabs">
      <div class="panel-tab active" data-tab="chat">üí¨ Chat</div>
      <div class="panel-tab" data-tab="memory">üß† Memory</div>
      <div class="panel-tab" data-tab="status">üìä Status</div>
      <div class="panel-tab" data-tab="files">üìÅ Files</div>
    </div>

    <div class="tab-content">
      <!-- Chat Tab -->
      <div class="tab-pane active" id="tab-chat">
        <div class="chat-header-bar" style="padding: 8px 15px; border-bottom: 1px solid #333; display: flex; justify-content: space-between; align-items: center;">
          <span style="font-size: 0.85rem; color: #888;" id="chatChannelName">#hq</span>
          <span id="wsStatus" style="font-size: 0.7rem; color: #555;">Connecting...</span>
        </div>
        <div class="chat-messages" id="chatMessages" style="flex: 1; overflow-y: auto; padding: 15px; min-height: 0;">
          <div class="chat-loading" style="text-align: center; color: #666; padding: 20px;">Loading messages...</div>
        </div>
        <div class="chat-input-container" style="padding: 10px 15px; border-top: 1px solid #333; display: flex; gap: 10px; align-items: flex-end;">
          <textarea id="chatInput" placeholder="Type a message..." style="flex: 1; background: #2a2a2a; border: 1px solid #444; border-radius: 8px; padding: 10px 15px; color: #fff; font-size: 0.9rem; resize: none; min-height: 40px; max-height: 200px; overflow-y: auto; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.4;" rows="1"></textarea>
          <button id="chatSend" style="background: #5865F2; border: none; border-radius: 8px; padding: 10px 20px; color: white; cursor: pointer; font-weight: 500; flex-shrink: 0;">Send</button>
        </div>
      </div>

      <!-- Memory Tab -->
      <div class="tab-pane" id="tab-memory">
        <div class="memory-section">
          <h3>Loading...</h3>
        </div>
      </div>

      <!-- Status Tab -->
      <div class="tab-pane" id="tab-status">
        <div class="status-section">
          <h3>Loading...</h3>
        </div>
      </div>

      <!-- Files Tab -->
      <div class="tab-pane" id="tab-files">
        <div class="files-section">
          <div class="files-header">
            <h3>üìÅ Files for Review</h3>
            <button class="refresh-btn" onclick="fetchFiles()">‚Üª</button>
          </div>
          <div id="filesList" class="files-list">
            <div class="no-files">No files pending review</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Mobile Bottom Navigation -->
  <div class="mobile-bottom-nav" id="mobileBottomNav">
    <button class="mobile-nav-item" data-agent="isla">
      <div class="mobile-nav-emoji">üèùÔ∏è</div>
      <div class="mobile-nav-name">Isla</div>
    </button>
    <button class="mobile-nav-item" data-agent="marcus">
      <div class="mobile-nav-emoji">üîß</div>
      <div class="mobile-nav-name">Marcus</div>
    </button>
    <button class="mobile-nav-item" data-agent="harper">
      <div class="mobile-nav-emoji">üîç</div>
      <div class="mobile-nav-name">Harper</div>
    </button>
    <button class="mobile-nav-item" data-agent="eli">
      <div class="mobile-nav-emoji">üèóÔ∏è</div>
      <div class="mobile-nav-name">Eli</div>
    </button>
    <button class="mobile-nav-item" data-agent="sage">
      <div class="mobile-nav-emoji">üî≠</div>
      <div class="mobile-nav-name">Sage</div>
    </button>
    <button class="mobile-nav-item" data-agent="julie">
      <div class="mobile-nav-emoji">üì£</div>
      <div class="mobile-nav-name">Julie</div>
    </button>
    <button class="mobile-nav-item" data-agent="dash">
      <div class="mobile-nav-emoji">üé®</div>
      <div class="mobile-nav-name">Dash</div>
    </button>
    <button class="mobile-nav-item" data-agent="remy">
      <div class="mobile-nav-emoji">üç≥</div>
      <div class="mobile-nav-name">Remy</div>
    </button>
    <button class="mobile-nav-item" data-agent="lena">
      <div class="mobile-nav-emoji">üí™</div>
      <div class="mobile-nav-name">Lena</div>
    </button>
    <button class="mobile-nav-item" data-agent="val">
      <div class="mobile-nav-emoji">üí∞</div>
      <div class="mobile-nav-name">Val</div>
    </button>
    <button class="mobile-nav-item" data-agent="atlas">
      <div class="mobile-nav-emoji">üó∫Ô∏è</div>
      <div class="mobile-nav-name">Atlas</div>
    </button>
  </div>
  
  <script src="config.js"></script>
  <script>
    const sidePanel = document.getElementById('sidePanel');
    const agents = document.querySelectorAll('.agent');
    const panelClose = document.getElementById('panelClose');
    const tabs = document.querySelectorAll('.panel-tab');
    const chatInput = document.getElementById('chatInput');
    const chatSend = document.getElementById('chatSend');
    const chatMessages = document.getElementById('chatMessages');

    let selectedAgent = null;

    // Update office time display
    function updateOfficeTime() {
      const now = new Date();
      const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      const dayName = days[now.getDay()];
      const time = now.toLocaleTimeString('en-US', {
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
      document.getElementById('officeTime').textContent = `üè¢ The Office - ${dayName} ${time}`;
    }

    // Update immediately and every minute
    updateOfficeTime();
    setInterval(updateOfficeTime, 60000);

    // Agent greetings
    const agentGreetings = {
      isla: "Hey! What can I help you with?",
      marcus: "What's up? Got a PR for me to look at?",
      harper: "Testing something right now, but I can chat. What's up?",
      eli: "Thinking about patterns. What do you need?",
      sage: "Just found something interesting. What's on your mind?",
      julie: "Hey! Working on some copy. What do you need?",
      dash: "Building something cool. Want to see what I'm working on?",
      remy: "Kitchen's open. What can I help with?",
      lena: "Ready when you are. What's up?",
      val: "Numbers looking good. What do you need?"
    };

    // Agent channel names (no Discord dependency)
    const agentChannels = {
      isla: { name: "#hq" },
      marcus: { name: "#mhc" },
      harper: { name: "#qa" },
      eli: { name: "#cto-dev" },
      sage: { name: "#research" },
      julie: { name: "#marketing" },
      dash: { name: "#dash" },
      remy: { name: "#chef" },
      lena: { name: "#gym" },
      val: { name: "#finance" }
    };

    // API endpoint - same origin (server.js on port 3000)
    const API_BASE = '/api';

    // Gateway WebSocket config - proxied through dashboard server
    const wsProto = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const GATEWAY_WS_URL = `${wsProto}//${window.location.host}/gw`;
    const GATEWAY_TOKEN = config.gatewayToken;

    // Extract text from an OpenClaw message object
    // Messages have shape: { role, content: string | [{ type: "text", text: "..." }, ...], timestamp }
    function extractMessageText(message) {
      if (!message) return '';
      if (typeof message === 'string') return message;
      const content = message.content;
      if (typeof content === 'string') return content;
      if (Array.isArray(content)) {
        return content
          .filter(item => item.type === 'text' && typeof item.text === 'string')
          .map(item => item.text)
          .join('\n');
      }
      if (typeof message.text === 'string') return message.text;
      return '';
    }

    // --- Gateway WebSocket Connection ---
    let gwSocket = null;
    let gwConnected = false;
    let gwRequestId = 0;
    let gwPendingRequests = new Map(); // id -> { resolve, reject }
    let gwChatCallbacks = new Map(); // sessionKey -> { onDelta, onFinal, onError }

    function gwNextId() { return `req-${++gwRequestId}`; }

    function gwConnect() {
      if (gwSocket && gwSocket.readyState <= 1) return; // already open/connecting

      console.log('[GW] Connecting to', GATEWAY_WS_URL);
      gwSocket = new WebSocket(GATEWAY_WS_URL);

      gwSocket.onopen = () => {
        console.log('[GW] WebSocket open, sending connect...');
        const connId = gwNextId();
        gwSendRaw({
          type: 'req', id: connId, method: 'connect',
          params: {
            minProtocol: 3, maxProtocol: 3,
            client: { id: 'webchat-ui', version: '1.0.0', platform: 'web', mode: 'ui' },
            role: 'operator',
            scopes: ['operator.read', 'operator.write'],
            auth: { token: GATEWAY_TOKEN }
          }
        });
        gwPendingRequests.set(connId, {
          resolve: (payload) => {
            gwConnected = true;
            console.log('[GW] Connected!', payload.server?.version);
            const wsEl = document.getElementById('wsStatus');
            if (wsEl) { wsEl.textContent = 'Live'; wsEl.style.color = '#22c55e'; }
          },
          reject: (err) => console.error('[GW] Connect failed:', err)
        });
      };

      gwSocket.onmessage = (event) => {
        let frame;
        try { frame = JSON.parse(event.data); } catch { return; }

        // Response to a request
        if (frame.type === 'res' && frame.id) {
          const pending = gwPendingRequests.get(frame.id);
          if (pending) {
            gwPendingRequests.delete(frame.id);
            if (frame.ok) pending.resolve(frame.payload);
            else pending.reject(frame.error);
          }
        }

        // Streaming chat event
        if (frame.type === 'event' && frame.event === 'chat') {
          const p = frame.payload;
          // Find callback for this sessionKey
          for (const [key, cb] of gwChatCallbacks) {
            if (p.sessionKey && p.sessionKey === key) {
              if (p.state === 'delta' && p.message) {
                const text = extractMessageText(p.message);
                if (text) cb.onDelta(text, p);
              }
              else if (p.state === 'final') {
                // Final event may carry the complete message - apply it before finalizing
                if (p.message) {
                  const text = extractMessageText(p.message);
                  if (text) cb.onDelta(text, p);
                }
                cb.onFinal(p);
              }
              else if (p.state === 'error' || p.state === 'aborted') cb.onError(p);
            }
          }
        }

        // Keepalive
        if (frame.type === 'event' && frame.event === 'tick') {
          // no-op, connection is alive
        }
      };

      gwSocket.onclose = () => {
        gwConnected = false;
        console.log('[GW] WebSocket closed, reconnecting in 3s...');
        const wsEl = document.getElementById('wsStatus');
        if (wsEl) { wsEl.textContent = 'Reconnecting...'; wsEl.style.color = '#f59e0b'; }
        setTimeout(gwConnect, 3000);
      };

      gwSocket.onerror = (e) => {
        console.error('[GW] WebSocket error:', e);
      };
    }

    function gwSendRaw(data) {
      if (gwSocket && gwSocket.readyState === 1) {
        gwSocket.send(JSON.stringify(data));
      }
    }

    function gwRequest(method, params = {}) {
      return new Promise((resolve, reject) => {
        if (!gwSocket || gwSocket.readyState !== 1) {
          reject(new Error('WebSocket not connected'));
          return;
        }
        const id = gwNextId();
        gwPendingRequests.set(id, { resolve, reject });
        gwSendRaw({ type: 'req', id, method, params });
        // Timeout after 60s
        setTimeout(() => {
          if (gwPendingRequests.has(id)) {
            gwPendingRequests.delete(id);
            reject(new Error('Request timeout'));
          }
        }, 60000);
      });
    }

    // Start WebSocket connection
    gwConnect();

    // Cache for agent data
    let agentMemoryCache = {};

    // Fetch agent memory from API
    async function fetchAgentMemory(agentKey) {
      if (agentMemoryCache[agentKey]) return agentMemoryCache[agentKey];
      try {
        const response = await fetch(`${API_BASE}/agent/${agentKey}`);
        if (response.ok) {
          const data = await response.json();
          agentMemoryCache[agentKey] = data;
          return data;
        }
      } catch (e) { console.log('Memory fetch failed:', e); }
      return { knowledge: [{ text: "Unable to load memory" }], learned: [], pending: [] };
    }

    // Clear cache to force refresh
    function clearMemoryCache() {
      agentMemoryCache = {};
    }

    // Status polling
    async function pollStatus() {
      try {
        const response = await fetch(`${API_BASE}/status`);
        if (response.ok) {
          const statuses = await response.json();
          updateStatusIndicators(statuses);
        }
      } catch (e) {
        console.log('Status poll failed:', e);
      }
    }

    function updateStatusIndicators(statuses) {
      for (const [agentKey, status] of Object.entries(statuses)) {
        const agentEl = document.querySelector(`.agent.${agentKey}`);
        if (!agentEl) continue;

        const statusDot = agentEl.querySelector('.status-dot');
        const taskEl = agentEl.querySelector('.agent-task');

        if (statusDot) {
          // Remove all status classes
          statusDot.classList.remove('status-working', 'status-idle', 'status-thinking', 'status-meeting');

          // Add appropriate class
          switch (status.state) {
            case 'working':
              statusDot.classList.add('status-working');
              break;
            case 'thinking':
              statusDot.classList.add('status-thinking');
              break;
            case 'meeting':
              statusDot.classList.add('status-meeting');
              break;
            default:
              statusDot.classList.add('status-idle');
          }
        }

        if (taskEl && status.task) {
          taskEl.textContent = status.task;
        }
      }
    }

    // Poll every 10 seconds
    setInterval(pollStatus, 10000);

    // Initial poll
    pollStatus();

    // Interactions
    async function pollInteractions() {
      try {
        const response = await fetch(`${API_BASE}/interactions/active`);
        if (response.ok) {
          const active = await response.json();
          drawInteractionLines(active);
          updateInteractionFeed(active);
        }
      } catch (e) {
        console.log('Interactions poll failed:', e);
      }
    }

    function drawInteractionLines(interactions) {
      // Remove existing lines
      document.querySelectorAll('.interaction-line').forEach(el => el.remove());
      // Interaction lines disabled - they cause layout thrashing with agent animations.
      // The interaction feed panel shows active conversations instead.
    }

    function updateInteractionFeed(interactions) {
      const feed = document.getElementById('interactionFeed');
      if (!feed) return;

      if (interactions.length === 0) {
        feed.innerHTML = '<div class="no-interactions">No recent interactions</div>';
        return;
      }

      feed.innerHTML = interactions.slice(0, 5).map(i => `
        <div class="interaction-item">
          <span class="interaction-agents">${i.from} ‚Üí ${i.to}</span>
          <span class="interaction-topic">${i.topic}</span>
        </div>
      `).join('');
    }

    // Poll interactions every 5 seconds
    setInterval(pollInteractions, 5000);
    pollInteractions();

    // Action Items Management
    async function getActionItems() {
      // Fetch from server
      try {
        const response = await fetch(`${API_BASE}/action-items`);
        if (response.ok) {
          const data = await response.json();
          if (data.ok) {
            return data.items;
          }
        }
      } catch (e) {
        console.error('Failed to fetch action items:', e);
      }
      return [];
    }

    async function saveActionItems(items) {
      // Not used anymore - we update individual items via API
    }

    function addActionItem(text) {
      // This is called by the global API function after the item is added server-side
      fetchPriorities(); // Refresh display
    }

    async function handleActionItemToggle(e) {
      const idx = parseInt(e.target.dataset.actionIdx);
      const completed = e.target.checked;

      try {
        const response = await fetch(`${API_BASE}/action-items/${idx}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ completed })
        });

        if (response.ok) {
          // Update parent div styling
          const actionDiv = e.target.closest('.action-item');
          if (completed) {
            actionDiv.classList.add('completed');
          } else {
            actionDiv.classList.remove('completed');
          }
        }
      } catch (e) {
        console.error('Failed to update action item:', e);
        // Revert checkbox on error
        e.target.checked = !completed;
      }
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // API to add action items (called by agents or from console)
    window.addActionItemFromAgent = async function(text, agentName) {
      try {
        const response = await fetch(`${API_BASE}/action-items/add`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text, agent: agentName })
        });

        const result = await response.json();
        if (result.ok) {
          console.log(`‚úÖ Action item added by ${agentName || 'system'}: ${text}`);
          fetchPriorities(); // Refresh display
          return true;
        }
        return false;
      } catch (e) {
        console.error('Failed to add action item:', e);
        return false;
      }
    };

    // Fetch and display Jeremy's priorities
    async function fetchPriorities() {
      try {
        const response = await fetch(`${API_BASE}/today`);
        if (response.ok) {
          const data = await response.json();
          if (data.ok) {
            renderPriorities(data);
          }
        }
      } catch (e) {
        console.log('Priorities fetch failed:', e);
      }
    }

    async function renderPriorities(data) {
      const container = document.getElementById('prioritiesContent');
      const updatedEl = document.getElementById('prioritiesUpdated');

      if (data.updated) {
        updatedEl.textContent = data.updated;
      }

      let html = '';

      // Action Items (from server)
      const actionItems = await getActionItems();
      if (actionItems.length > 0) {
        const hasCompleted = actionItems.some(item => item.completed);
        html += '<div class="priority-section">';
        html += '<div class="priority-section-title">';
        html += '<span>Action Items</span>';
        if (hasCompleted) {
          html += '<button class="clear-completed-btn" id="clearCompletedBtn">Clear Completed</button>';
        }
        html += '</div>';
        actionItems.forEach((item, idx) => {
          const checkedAttr = item.completed ? 'checked' : '';
          const completedClass = item.completed ? 'completed' : '';
          html += `
            <div class="action-item ${completedClass}">
              <input type="checkbox" ${checkedAttr} data-action-idx="${idx}">
              <span class="action-item-text">${escapeHtml(item.text)}</span>
            </div>
          `;
        });
        html += '</div>';
      }

      if (data.focus && data.focus.length > 0) {
        html += '<div class="priority-section"><div class="priority-section-title">Focus</div>';
        data.focus.forEach(item => {
          html += `<div class="priority-item">${item}</div>`;
        });
        html += '</div>';
      }

      if (data.blocked && data.blocked.length > 0) {
        html += '<div class="priority-section"><div class="priority-section-title">Blocked</div>';
        data.blocked.forEach(item => {
          html += `<div class="priority-item blocked">${item}</div>`;
        });
        html += '</div>';
      }

      if (data.notes && data.notes.length > 0) {
        html += '<div class="priority-section"><div class="priority-section-title">Notes</div>';
        data.notes.forEach(item => {
          html += `<div class="priority-item note">${item}</div>`;
        });
        html += '</div>';
      }

      if (!html) {
        html = '<div class="no-interactions">No priorities set</div>';
      }

      container.innerHTML = html;

      // Attach checkbox event listeners
      container.querySelectorAll('.action-item input[type="checkbox"]').forEach(checkbox => {
        checkbox.addEventListener('change', handleActionItemToggle);
      });

      // Attach clear completed button listener
      const clearBtn = document.getElementById('clearCompletedBtn');
      if (clearBtn) {
        clearBtn.addEventListener('click', clearCompletedActionItems);
      }
    }

    async function clearCompletedActionItems() {
      try {
        const response = await fetch(`${API_BASE}/action-items/clear-completed`, {
          method: 'DELETE'
        });

        if (response.ok) {
          const data = await response.json();
          console.log(`üóëÔ∏è Cleared ${data.removed} completed action items`);
          fetchPriorities(); // Refresh display
        }
      } catch (e) {
        console.error('Failed to clear completed items:', e);
      }
    }

    // Poll priorities every 30 seconds
    setInterval(fetchPriorities, 30000);
    fetchPriorities();

    // Fetch and display daily standup
    async function fetchStandup() {
      try {
        const response = await fetch(`${API_BASE}/standup`);
        if (response.ok) {
          const data = await response.json();
          if (data.ok) {
            renderStandup(data);
          }
        }
      } catch (e) {
        console.log('Standup fetch failed:', e);
      }
    }

    function renderStandup(data) {
      const container = document.getElementById('standupContent');
      const dateEl = document.getElementById('standupDate');

      if (data.date) {
        dateEl.textContent = `${data.date}`;
      }

      if (!data.updates || data.updates.length === 0) {
        container.innerHTML = '<div class="no-interactions">No updates</div>';
        return;
      }

      let html = '';
      data.updates.forEach(update => {
        html += `
          <div class="standup-item-expanded">
            <div class="standup-agent">
              <span class="agent-emoji">${update.emoji}</span>
              <span class="agent-name">${update.name}</span>
            </div>
            <div class="standup-status">${escapeHtml(update.status)}</div>
          </div>
        `;
      });

      container.innerHTML = html;
    }

    // Poll standup every 2 minutes
    setInterval(fetchStandup, 120000);
    fetchStandup();

    // Left Panel Tab Switching
    document.querySelectorAll('.left-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        const targetTab = tab.dataset.tab;

        // Update active tab
        document.querySelectorAll('.left-tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');

        // Update active content
        document.querySelectorAll('.left-tab-content').forEach(c => c.classList.remove('active'));
        document.getElementById(`tab-${targetTab}`).classList.add('active');

        // Save preference
        localStorage.setItem('leftPanelTab', targetTab);
      });
    });

    // Restore last active tab
    const savedTab = localStorage.getItem('leftPanelTab');
    if (savedTab) {
      const tab = document.querySelector(`.left-tab[data-tab="${savedTab}"]`);
      if (tab) tab.click();
    }

    // Folder state persistence
    function getFolderStates() {
      const stored = localStorage.getItem('folderStates');
      return stored ? JSON.parse(stored) : {};
    }

    function saveFolderState(folderPath, isCollapsed) {
      const states = getFolderStates();
      states[folderPath] = isCollapsed;
      localStorage.setItem('folderStates', JSON.stringify(states));
    }

    function isFolderCollapsed(folderPath) {
      const states = getFolderStates();
      // Default to expanded (false) if not set
      return states[folderPath] === true;
    }

    // Fetch files for review
    async function fetchFiles() {
      try {
        const response = await fetch(`${API_BASE}/files`);
        if (response.ok) {
          const data = await response.json();
          if (data.ok) {
            renderFiles(data.tree || data.files); // Support both formats
          }
        }
      } catch (e) {
        console.log('Files fetch failed:', e);
      }
    }

    function renderFiles(items) {
      const container = document.getElementById('filesList');

      if (!items || items.length === 0) {
        container.innerHTML = '<div class="no-files">No files found</div>';
        return;
      }

      container.innerHTML = renderFileTree(items, 0);

      // Add click handlers for folder toggles
      container.querySelectorAll('.folder-toggle').forEach(toggle => {
        toggle.addEventListener('click', (e) => {
          e.stopPropagation();
          const folder = e.target.closest('.folder-item');
          const folderPath = folder.dataset.path;
          const isCollapsed = folder.classList.toggle('collapsed');

          // Save the state
          saveFolderState(folderPath, isCollapsed);
        });
      });

      // Add click handlers for file items
      container.querySelectorAll('.file-item').forEach(fileItem => {
        fileItem.addEventListener('click', () => {
          const filePath = fileItem.dataset.path;
          const fileName = fileItem.dataset.name;
          viewFile(filePath, fileName);
        });
      });
    }

    function renderFileTree(items, depth = 0) {
      return items.map(item => {
        if (item.type === 'folder') {
          const indent = depth * 15;
          const isCollapsed = isFolderCollapsed(item.path);
          const collapsedClass = isCollapsed ? 'collapsed' : '';
          return `
            <div class="folder-item ${collapsedClass}" style="margin-left: ${indent}px;" data-path="${item.path}">
              <div class="folder-header">
                <span class="folder-toggle">üìÅ</span>
                <span class="folder-name">${escapeHtml(item.name)}</span>
              </div>
              <div class="folder-children">
                ${renderFileTree(item.children, depth + 1)}
              </div>
            </div>
          `;
        } else {
          const indent = depth * 15;
          return `
            <div class="file-item" style="margin-left: ${indent}px;" data-path="${item.path}" data-name="${escapeHtml(item.name)}">
              <div class="file-name">üìÑ ${escapeHtml(item.name)}</div>
              <div class="file-meta">
                <span>${item.modifiedFormatted}</span>
                <span>${Math.round(item.size / 1024) || 1} KB</span>
              </div>
              <div class="file-preview">${escapeHtml(item.preview)}</div>
            </div>
          `;
        }
      }).join('');
    }

    async function viewFile(filePath, fileName) {
      try {
        const response = await fetch(`${API_BASE}/file/${filePath}`);
        if (response.ok) {
          const data = await response.json();
          if (data.ok) {
            showFileViewer(fileName, data.content);
          }
        }
      } catch (e) {
        alert('Failed to load file: ' + e.message);
      }
    }

    function showFileViewer(fileName, content) {
      const viewer = document.createElement('div');
      viewer.className = 'file-viewer';

      // Check file type
      const isMarkdown = fileName.toLowerCase().endsWith('.md');
      const isHtml = fileName.toLowerCase().endsWith('.html') || fileName.toLowerCase().endsWith('.htm');
      let renderedContent;
      let viewerClass = '';
      let blobUrl = null;

      if (isHtml) {
        // Render HTML in an iframe
        const blob = new Blob([content], { type: 'text/html' });
        blobUrl = URL.createObjectURL(blob);
        viewer.innerHTML = `
          <div class="file-viewer-header">
            <h2>üìÑ ${escapeHtml(fileName)}</h2>
            <button class="file-viewer-close">Close</button>
          </div>
          <iframe src="${blobUrl}" style="flex: 1; border: none; background: #fff; border-radius: 8px;"></iframe>
        `;
      } else if (isMarkdown && typeof marked !== 'undefined') {
        // Configure marked for better rendering
        marked.setOptions({
          breaks: true,
          gfm: true,
          headerIds: true,
          mangle: false
        });
        renderedContent = marked.parse(content);
        viewerClass = 'markdown-view';
        viewer.innerHTML = `
          <div class="file-viewer-header">
            <h2>üìÑ ${escapeHtml(fileName)}</h2>
            <button class="file-viewer-close">Close</button>
          </div>
          <div class="file-viewer-content ${viewerClass}">${renderedContent}</div>
        `;
      } else {
        // Plain text view for non-markdown files
        renderedContent = escapeHtml(content);
        viewer.innerHTML = `
          <div class="file-viewer-header">
            <h2>üìÑ ${escapeHtml(fileName)}</h2>
            <button class="file-viewer-close">Close</button>
          </div>
          <div class="file-viewer-content ${viewerClass}">${renderedContent}</div>
        `;
      }

      document.body.appendChild(viewer);

      // Add close button event listener
      const closeBtn = viewer.querySelector('.file-viewer-close');
      console.log('[File Viewer] Close button found:', closeBtn);
      if (closeBtn) {
        closeBtn.addEventListener('click', (e) => {
          console.log('[File Viewer] Close button clicked!');
          e.preventDefault();
          e.stopPropagation();
          if (blobUrl) {
            console.log('[File Viewer] Revoking blob URL:', blobUrl);
            URL.revokeObjectURL(blobUrl);
          }
          console.log('[File Viewer] Removing viewer');
          viewer.remove();
        });
        console.log('[File Viewer] Event listener attached');
      } else {
        console.error('[File Viewer] Close button NOT found!');
      }
    }

    // Poll files every 30 seconds
    setInterval(fetchFiles, 30000);
    fetchFiles();

    // Agent default positions (for returning after interaction)
    const defaultPositions = {
      marcus: { top: 50, left: 40 },
      harper: { top: 50, left: 160 },
      eli: { top: 50, left: 280 },
      sage: { top: 50, left: 400 },
      dash: { top: 170, left: 40 },
      julie: { top: 170, left: 220 },
      remy: { top: 60, right: 100 },
      lena: { top: 140, right: 100 },
      val: { top: 270, right: 100 },
      atlas: { bottom: 130, right: 130 },
      isla: { bottom: 35 }
    };

    // Conference table seats (positions around the table)
    const conferenceSeats = [
      { top: 350, left: 120 },  // seat 1
      { top: 350, left: 220 },  // seat 2
      { top: 350, left: 320 },  // seat 3
      { top: 350, left: 420 },  // seat 4
      { top: 430, left: 120 },  // seat 5
      { top: 430, left: 220 },  // seat 6
      { top: 430, left: 320 },  // seat 7
      { top: 430, left: 420 },  // seat 8
    ];

    // Movement state
    let seatAssignments = {}; // agent -> seat index
    let movedAgents = new Set(); // agents currently away from their desk
    let currentMeeting = null; // "standup" | null

    // Show a brief toast notification (auto-removes, no stacking)
    let activeNotification = null;
    function showMovementNotification(text) {
      if (activeNotification) activeNotification.remove();
      const el = document.createElement('div');
      el.style.cssText = 'position:fixed;top:80px;right:20px;background:rgba(14,165,233,0.95);color:#fff;padding:12px 20px;border-radius:8px;font-size:0.85rem;font-weight:500;box-shadow:0 4px 12px rgba(0,0,0,0.3);z-index:200;opacity:0;transition:opacity 0.3s;';
      el.textContent = text;
      document.body.appendChild(el);
      activeNotification = el;
      requestAnimationFrame(() => el.style.opacity = '1');
      setTimeout(() => {
        el.style.opacity = '0';
        setTimeout(() => { el.remove(); if (activeNotification === el) activeNotification = null; }, 300);
      }, 3000);
    }

    // Move agent to a position (CSS transition handles the walk)
    function moveAgent(agentKey, position) {
      const el = document.querySelector(`.agent.${agentKey}`);
      if (!el) return;
      // Override any CSS transforms (e.g., isla's translateX(-50%)) so position is accurate
      el.style.transform = 'none';
      if (position.left !== undefined) { el.style.left = position.left + 'px'; el.style.right = 'auto'; }
      if (position.right !== undefined) { el.style.right = position.right + 'px'; el.style.left = 'auto'; }
      if (position.top !== undefined) { el.style.top = position.top + 'px'; el.style.bottom = 'auto'; }
      if (position.bottom !== undefined) { el.style.bottom = position.bottom + 'px'; el.style.top = 'auto'; }
    }

    // Return agent to their default desk
    function returnToDesk(agentKey) {
      const el = document.querySelector(`.agent.${agentKey}`);
      if (!el) return;
      // Clear all inline position/transform styles - CSS class positions take over
      // The transition property still animates the change smoothly
      el.style.removeProperty('left');
      el.style.removeProperty('right');
      el.style.removeProperty('top');
      el.style.removeProperty('bottom');
      el.style.removeProperty('transform');
      delete seatAssignments[agentKey];
      movedAgents.delete(agentKey);
    }

    // Walk one agent over to another agent's desk
    function walkAgentTo(fromAgent, toAgent) {
      if (movedAgents.has(fromAgent)) return; // already walked somewhere
      const toPos = defaultPositions[toAgent];
      if (!toPos) return;
      // Place the walking agent next to the target (offset by ~80px)
      const dest = {};
      if (toPos.left !== undefined) { dest.top = toPos.top; dest.left = toPos.left + 80; }
      else if (toPos.right !== undefined) { dest.top = toPos.top; dest.right = toPos.right + 80; }
      else { dest.bottom = (toPos.bottom || 35) + 60; dest.left = 280; } // near Isla (centered bottom)
      moveAgent(fromAgent, dest);
      movedAgents.add(fromAgent);
      const fromName = fromAgent.charAt(0).toUpperCase() + fromAgent.slice(1);
      const toName = toAgent.charAt(0).toUpperCase() + toAgent.slice(1);
      showMovementNotification(`${fromName} walked over to ${toName}'s desk`);
    }

    // One agent walks to the other's desk for a chat
    function moveForChat(agentA, agentB) {
      if (movedAgents.has(agentA)) return; // already in position
      walkAgentTo(agentA, agentB);
    }

    // Start a meeting - move everyone to conference
    function startMeeting(meetingType) {
      currentMeeting = meetingType;
      const allAgents = ['isla', 'marcus', 'harper', 'eli', 'sage', 'dash', 'julie', 'remy', 'lena', 'val'];
      allAgents.forEach((agent, idx) => {
        if (idx < conferenceSeats.length) {
          moveAgent(agent, conferenceSeats[idx]);
          seatAssignments[agent] = idx;
          movedAgents.add(agent);
        }
      });
    }

    // End meeting - everyone returns to desks
    function endMeeting() {
      currentMeeting = null;
      ['isla', 'marcus', 'harper', 'eli', 'sage', 'dash', 'julie', 'remy', 'lena', 'val'].forEach(returnToDesk);
    }

    // Poll-driven animation (called every 5s - must be cheap)
    function animateAgentMovement(interactions) {
      if (currentMeeting) return;
      const interacting = new Set();
      for (const i of interactions) {
        interacting.add(i.from);
        interacting.add(i.to);
      }
      // Move newly interacting agents
      const handled = new Set();
      for (const i of interactions) {
        if (handled.has(i.from) || handled.has(i.to)) continue;
        moveForChat(i.from, i.to);
        handled.add(i.from);
        handled.add(i.to);
      }
      // Return agents whose interactions ended
      for (const agent of movedAgents) {
        if (!interacting.has(agent)) returnToDesk(agent);
      }
    }

    // Poll interactions
    const originalPollInteractions = pollInteractions;
    pollInteractions = async function() {
      try {
        const response = await fetch(`${API_BASE}/interactions/active`);
        if (response.ok) {
          const active = await response.json();
          drawInteractionLines(active);
          updateInteractionFeed(active);
          animateAgentMovement(active);
        }
      } catch (e) {
        console.log('Interactions poll failed:', e);
      }
    };

    function renderMemorySection(data, agentKey, quote) {
      const memoryPane = document.getElementById('tab-memory');

      let knowledgeHtml = '';
      if (data.knowledge && data.knowledge.length > 0) {
        knowledgeHtml = data.knowledge.slice(0, 5).map(item =>
          `<div class="memory-item">${item.text}</div>`
        ).join('');
      }

      let learnedHtml = '';
      if (data.learned && data.learned.length > 0) {
        learnedHtml = data.learned.map(item =>
          `<div class="memory-item">
            ${item.text}
            <div class="source">${item.source} ‚Ä¢ ${item.when}</div>
          </div>`
        ).join('');
      } else {
        learnedHtml = '<div class="memory-item">No cross-agent learnings yet</div>';
      }

      memoryPane.innerHTML = `
        <div class="memory-section">
          <h3>Current Knowledge</h3>
          ${knowledgeHtml || '<div class="memory-item">No knowledge recorded</div>'}
        </div>

        <div class="memory-section">
          <h3>Learned From Others</h3>
          ${learnedHtml}
        </div>

        <div class="agent-quote">"${quote}"</div>
      `;
    }

    function renderStatusSection(data, quote) {
      const statusPane = document.getElementById('tab-status');

      // Today section (for daily-status agents like Remy, Lena)
      let todayHtml = '';
      if (data.today && data.today.length > 0) {
        todayHtml = `
          <div class="status-section recent-activity">
            <h3>üìÖ Today</h3>
            ${data.today.map(item =>
              `<div class="activity-item">
                <span class="activity-text">${item.text}</span>
              </div>`
            ).join('')}
          </div>
        `;
      }

      // Pending section
      let pendingHtml = '';
      if (data.pending && data.pending.length > 0) {
        pendingHtml = `
          <div class="status-section recent-activity">
            <h3>Pending Tasks</h3>
            ${data.pending.map(item =>
              `<div class="activity-item">
                <span class="activity-time">${item.done ? '‚úÖ' : '‚è≥'}</span>
                <span class="activity-text">${item.text}</span>
              </div>`
            ).join('')}
          </div>
        `;
      } else if (!data.today || data.today.length === 0) {
        pendingHtml = `
          <div class="status-section recent-activity">
            <h3>Pending Tasks</h3>
            <div class="activity-item"><span class="activity-text">No pending tasks</span></div>
          </div>
        `;
      }

      statusPane.innerHTML = `
        <div class="status-section">
          <h3>Current Status</h3>
          <div class="status-grid">
            <div class="status-card">
              <div class="label">State</div>
              <div class="value green">Active</div>
            </div>
            <div class="status-card">
              <div class="label">Memory</div>
              <div class="value">${data.knowledge ? data.knowledge.length : 0} items</div>
            </div>
            <div class="status-card">
              <div class="label">Learned</div>
              <div class="value blue">${data.learned ? data.learned.length : 0}</div>
            </div>
            <div class="status-card">
              <div class="label">Today</div>
              <div class="value ${data.today && data.today.length > 0 ? 'green' : 'yellow'}">${data.today ? data.today.length : 0}</div>
            </div>
          </div>
        </div>

        ${todayHtml}
        ${pendingHtml}

        <div class="agent-quote">"${quote}"</div>
      `;
    }

    // Click on agent to open panel
    agents.forEach(agent => {
      agent.addEventListener('click', async () => {
        // Deselect previous
        if (selectedAgent) {
          selectedAgent.classList.remove('selected');
        }

        // Select new
        agent.classList.add('selected');
        selectedAgent = agent;

        // Update panel
        const name = agent.dataset.name;
        const role = agent.dataset.role;
        const emoji = agent.dataset.emoji;
        const quote = agent.dataset.quote;
        const agentKey = agent.classList[1]; // e.g., 'marcus'

        document.getElementById('panelAvatar').textContent = emoji;
        document.getElementById('panelName').textContent = name;
        document.getElementById('panelRole').textContent = role;

        // Update WebSocket status indicator
        document.getElementById('wsStatus').textContent = gwConnected ? 'Live' : 'Connecting...';
        document.getElementById('wsStatus').style.color = gwConnected ? '#22c55e' : '#f59e0b';

        // Load live chat for this agent
        loadAgentChat(agentKey);

        // Show panel immediately
        sidePanel.classList.remove('hidden');

        // Reset to chat tab
        tabs.forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-pane').forEach(p => p.classList.remove('active'));
        tabs[0].classList.add('active');
        document.getElementById('tab-chat').classList.add('active');

        // Fetch and render memory data (async)
        const memoryData = await fetchAgentMemory(agentKey);
        renderMemorySection(memoryData, agentKey, quote);
        renderStatusSection(memoryData, quote);
      });
    });

    // Close panel
    panelClose.addEventListener('click', () => {
      sidePanel.classList.add('hidden');
      if (selectedAgent) {
        selectedAgent.classList.remove('selected');
        selectedAgent = null;
      }
      // Hide overlay on mobile
      if (window.innerWidth <= 1200) {
        panelOverlay.classList.remove('active');
      }
    });

    // Tab switching
    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        tabs.forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-pane').forEach(p => p.classList.remove('active'));

        tab.classList.add('active');
        document.getElementById('tab-' + tab.dataset.tab).classList.add('active');
      });
    });

    // --- Chat System (WebSocket-based) ---
    let currentAgentKey = null;

    // Load drafts from localStorage on startup
    let messageDrafts = {};
    try {
      const stored = localStorage.getItem('messageDrafts');
      if (stored) messageDrafts = JSON.parse(stored);
    } catch (e) {
      console.error('Failed to load drafts:', e);
    }
    let chatMessagesCache = [];

    // Per-agent streaming state
    const agentStreamingState = new Map(); // agentKey -> { el, text }

    // Track unread messages per agent
    const unreadMessages = new Map(); // agentKey -> count

    // Mark agent as having unread messages
    function markUnread(agentKey) {
      if (agentKey === currentAgentKey) return; // Don't mark as unread if we're viewing it

      const count = (unreadMessages.get(agentKey) || 0) + 1;
      unreadMessages.set(agentKey, count);

      const agentEl = document.querySelector(`.agent.${agentKey}`);
      if (agentEl) {
        agentEl.classList.add('has-unread');
      }
    }

    // Clear unread for an agent
    function clearUnread(agentKey) {
      unreadMessages.set(agentKey, 0);

      const agentEl = document.querySelector(`.agent.${agentKey}`);
      if (agentEl) {
        agentEl.classList.remove('has-unread');
      }
    }

    // Session key for an agent
    function agentSessionKey(agentKey) {
      return `agent:${agentKey}:webchat:user`;
    }

    // Render messages in chat panel
    function renderChatMessages(messages) {
      console.log('[RENDER] Rendering', messages.length, 'messages');
      console.trace('[RENDER] Called from:');
      if (messages.length === 0) {
        chatMessages.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">Start a conversation...</div>';
        return;
      }

      chatMessages.innerHTML = messages.map((m) => {
        const isUser = !m.isBot;
        const bubbleClass = isUser ? 'you' : 'them';
        const avatarClass = isUser ? 'jeremy' : 'bot';
        const avatarEmoji = isUser ? 'üëë' : (selectedAgent?.dataset?.emoji || 'ü§ñ');

        return `
          <div class="message-bubble ${bubbleClass}">
            <div class="bubble-avatar ${avatarClass}">${avatarEmoji}</div>
            <div class="bubble-content">
              <div class="bubble-text">${formatMarkdown(m.content || '')}</div>
              <div class="bubble-time">${m.timestampFormatted || ''}</div>
            </div>
          </div>`;
      }).join('');

      chatMessages.scrollTop = chatMessages.scrollHeight;

      // Render any charts that were inserted
      setTimeout(() => renderPendingCharts(), 50);
    }

    // Chart ID counter for unique chart containers
    let chartIdCounter = 0;

    // Store chart configs to render after DOM insertion
    const pendingCharts = new Map();

    // Detect and extract chart data from text (JSON format)
    function extractChartData(text) {
      const charts = [];
      // Match code blocks that look like chart JSON
      const codeBlockPattern = /```(?:json|chart)?\s*\n?([\s\S]*?)```/g;
      let match;

      while ((match = codeBlockPattern.exec(text)) !== null) {
        try {
          const jsonStr = match[1].trim();
          const data = JSON.parse(jsonStr);

          // Check if it's a chart object
          if (data.type === 'chart' && data.chartType && data.data) {
            charts.push({
              raw: match[0],
              data: data,
              position: match.index
            });
          }
        } catch (e) {
          // Not valid JSON or not a chart, skip
        }
      }

      return charts;
    }

    // Render a chart using ApexCharts
    function renderChart(chartData) {
      const chartId = `chart-${++chartIdCounter}`;
      const { chartType, title, data, options = {} } = chartData;

      // Build ApexCharts options based on chart type
      let apexOptions = {
        chart: {
          type: chartType,
          height: 300,
          background: 'transparent',
          foreColor: '#e0e0e0',
          toolbar: {
            show: true,
            tools: {
              download: true,
              zoom: chartType === 'line' || chartType === 'area',
              pan: chartType === 'line' || chartType === 'area'
            }
          },
          animations: {
            enabled: true,
            speed: 800
          }
        },
        theme: {
          mode: 'dark'
        },
        grid: {
          borderColor: '#444',
          strokeDashArray: 3
        },
        tooltip: {
          theme: 'dark',
          style: {
            fontSize: '12px'
          }
        },
        legend: {
          position: 'bottom',
          labels: {
            colors: '#e0e0e0'
          }
        }
      };

      // Handle different chart types
      if (chartType === 'line' || chartType === 'area') {
        apexOptions.series = data.series;
        apexOptions.xaxis = {
          categories: data.labels,
          labels: {
            style: {
              colors: '#888'
            }
          }
        };
        apexOptions.yaxis = {
          title: {
            text: options.yAxisTitle || '',
            style: {
              color: '#888'
            }
          },
          labels: {
            style: {
              colors: '#888'
            }
          }
        };

        // Add goal line if specified
        if (options.goal) {
          apexOptions.annotations = {
            yaxis: [{
              y: options.goal,
              borderColor: '#f59e0b',
              strokeDashArray: 5,
              label: {
                text: `Goal: ${options.goal}`,
                style: {
                  color: '#fff',
                  background: '#f59e0b'
                }
              }
            }]
          };
        }

        apexOptions.stroke = {
          curve: 'smooth',
          width: 2
        };
      } else if (chartType === 'bar') {
        apexOptions.series = data.series;
        apexOptions.xaxis = {
          categories: data.labels,
          labels: {
            style: {
              colors: '#888'
            }
          }
        };
        apexOptions.yaxis = {
          title: {
            text: options.yAxisTitle || '',
            style: {
              color: '#888'
            }
          },
          labels: {
            style: {
              colors: '#888'
            }
          }
        };
        apexOptions.plotOptions = {
          bar: {
            borderRadius: 4,
            horizontal: options.horizontal || false
          }
        };
      } else if (chartType === 'pie' || chartType === 'donut') {
        apexOptions.series = data.values;
        apexOptions.labels = data.labels;
        apexOptions.chart.type = chartType;
      }

      // Store chart config for later rendering
      pendingCharts.set(chartId, apexOptions);

      // Return HTML for chart container (no script tag)
      const titleHtml = title ? `<div class="chart-title">${escapeHtml(title)}</div>` : '';
      return `
        <div class="chart-container">
          ${titleHtml}
          <div id="${chartId}" class="chart-wrapper" data-chart-pending="true"></div>
        </div>
      `;
    }

    // Render all pending charts after DOM insertion
    function renderPendingCharts() {
      if (typeof ApexCharts === 'undefined') {
        console.error('[CHART] ApexCharts not loaded!');
        return;
      }

      // Find all chart containers waiting to be rendered
      const pending = document.querySelectorAll('[data-chart-pending="true"]');
      console.log('[CHART] Rendering', pending.length, 'pending chart(s)');

      pending.forEach(container => {
        const chartId = container.id;
        const options = pendingCharts.get(chartId);

        if (options) {
          console.log('[CHART] Rendering chart:', chartId);
          // Remove the pending flag
          container.removeAttribute('data-chart-pending');

          // Render the chart
          const chart = new ApexCharts(container, options);
          chart.render();

          // Clean up
          pendingCharts.delete(chartId);
        }
      });
    }

    // Format markdown for messages (with chart support)
    function formatMarkdown(text) {
      if (!text) return '';

      // Extract any chart data first
      const charts = extractChartData(text);

      // Replace charts with placeholders before markdown processing
      let processedText = text;
      const chartPlaceholders = [];
      if (charts.length > 0) {
        console.log('[CHART] Found', charts.length, 'chart(s)');
        charts.forEach((chart, idx) => {
          // Use HTML comment as placeholder - markdown won't touch it
          const placeholder = `<!--CHART_${idx}-->`;
          chartPlaceholders.push(renderChart(chart.data));
          processedText = processedText.replace(chart.raw, placeholder);
        });
      }

      // Process markdown
      let html;
      if (typeof marked === 'undefined') {
        // Fallback to simple formatting if marked isn't loaded
        html = escapeHtml(processedText);
        html = html.replace(/```(\w*)\n?([\s\S]*?)```/g, '<pre><code>$2</code></pre>');
        html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
        html = html.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
        html = html.replace(/\*([^*]+)\*/g, '<em>$1</em>');
        html = html.replace(/~~([^~]+)~~/g, '<del>$1</del>');
        html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>');
        html = html.replace(/(https?:\/\/[^\s<]+)/g, '<a href="$1" target="_blank">$1</a>');
      } else {
        // Use marked for proper markdown rendering
        marked.setOptions({
          breaks: true,
          gfm: true,
          headerIds: false,
          mangle: false
        });
        html = marked.parse(processedText);
      }

      // Replace placeholders with actual chart HTML
      if (chartPlaceholders.length > 0) {
        console.log('[CHART] Replacing', chartPlaceholders.length, 'placeholder(s)');
        chartPlaceholders.forEach((chartHtml, idx) => {
          const placeholder = `<!--CHART_${idx}-->`;
          const beforeCount = html.split(placeholder).length - 1;
          html = html.split(placeholder).join(chartHtml);
          const afterCount = html.split(placeholder).length - 1;
          console.log('[CHART] Placeholder', idx, '- found:', beforeCount, 'replaced:', beforeCount - afterCount);
        });
      }

      return html;
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Append a user message bubble to the chat
    function appendUserMessage(text) {
      console.log('[APPEND] User message:', text.substring(0, 50));
      const ts = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
      // Remove placeholder if present
      const placeholder = chatMessages.querySelector('.chat-loading, div[style*="text-align: center"]');
      if (placeholder) placeholder.remove();

      const el = document.createElement('div');
      el.className = 'message-bubble you';
      el.innerHTML = `
        <div class="bubble-avatar jeremy">üëë</div>
        <div class="bubble-content">
          <div class="bubble-text">${escapeHtml(text)}</div>
          <div class="bubble-time">${ts}</div>
        </div>`;
      chatMessages.appendChild(el);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    // Get or create streaming state for an agent
    function getStreamingState(agentKey) {
      if (!agentStreamingState.has(agentKey)) {
        agentStreamingState.set(agentKey, { el: null, text: '' });
      }
      return agentStreamingState.get(agentKey);
    }

    // Create or get the streaming message element for agent response
    function getStreamingEl(agentKey) {
      const state = getStreamingState(agentKey);
      if (state.el) return state.el;

      const ts = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
      const emoji = selectedAgent?.dataset?.emoji || 'ü§ñ';

      const el = document.createElement('div');
      el.className = 'message-bubble them';
      el.innerHTML = `
        <div class="bubble-avatar bot">${emoji}</div>
        <div class="bubble-content">
          <div class="bubble-text streaming-text"><span class="typing-indicator">Thinking...</span></div>
          <div class="bubble-time">${ts}</div>
        </div>`;

      // Only append if we're viewing this agent
      if (currentAgentKey === agentKey) {
        chatMessages.appendChild(el);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }

      state.el = el;
      state.text = '';
      return el;
    }

    // Update streaming text - each delta is the full accumulated text, not a diff
    function updateStreamingText(agentKey, text) {
      const state = getStreamingState(agentKey);
      state.text = text;
      const el = getStreamingEl(agentKey);
      const textEl = el.querySelector('.streaming-text');
      if (textEl) {
        textEl.innerHTML = formatMarkdown(state.text);
        // Render any charts that were inserted
        setTimeout(() => renderPendingCharts(), 50);
      }

      // Only scroll if we're viewing this agent
      if (currentAgentKey === agentKey) {
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
    }

    // Finalize streaming message
    function finalizeStreaming(agentKey) {
      const state = getStreamingState(agentKey);
      if (state.el) {
        const textEl = state.el.querySelector('.streaming-text');
        if (textEl && state.text) {
          textEl.innerHTML = formatMarkdown(state.text);
          // Render any charts that were inserted
          setTimeout(() => renderPendingCharts(), 50);
        } else if (textEl && !state.text) {
          textEl.innerHTML = '<span style="color: #888; font-style: italic;">No response</span>';
        }
      }
      state.el = null;
      state.text = '';
    }

    // Save draft message for current agent
    function saveDraftForCurrentAgent() {
      if (currentAgentKey && chatInput.value.trim()) {
        messageDrafts[currentAgentKey] = chatInput.value;
      } else if (currentAgentKey) {
        delete messageDrafts[currentAgentKey];
      }
      // Persist to localStorage
      try {
        localStorage.setItem('messageDrafts', JSON.stringify(messageDrafts));
      } catch (e) {
        console.error('Failed to save drafts:', e);
      }
    }

    // Load draft message for agent
    function loadDraftForAgent(agentKey) {
      chatInput.value = messageDrafts[agentKey] || '';
      autoResizeTextarea(); // Resize to fit draft content
    }

    // Load chat for an agent
    async function loadAgentChat(agentKey) {
      console.log('[LOAD] loadAgentChat called for:', agentKey);
      console.trace('[LOAD] Called from:');

      // Prevent reloading if we're already viewing this agent
      if (currentAgentKey === agentKey) {
        console.log('[LOAD] Already viewing this agent, skipping reload');
        return;
      }

      // Save draft for previous agent
      saveDraftForCurrentAgent();

      currentAgentKey = agentKey;

      // Load draft for new agent
      loadDraftForAgent(agentKey);

      // Clear unread badge for this agent
      clearUnread(agentKey);

      // Update channel name
      const channelName = agentChannels[agentKey]?.name || `#${agentKey}`;
      document.getElementById('chatChannelName').textContent = channelName;

      chatMessages.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">Loading messages...</div>';

      // Try loading history from Gateway first (most up-to-date)
      if (gwConnected) {
        try {
          const history = await gwRequest('chat.history', {
            sessionKey: agentSessionKey(agentKey),
            limit: 50
          });
          // If we got gateway history and it has messages, show them
          if (history && history.messages && history.messages.length > 0) {
            const gwMessages = history.messages
              .filter(m => m.role === 'user' || m.role === 'assistant')
              .map(m => {
                const content = extractMessageText(m);
                const isBot = m.role === 'assistant';
                return {
                  id: m.id || `gw-${Date.now()}-${Math.random()}`,
                  content,
                  author: isBot ? (agentKey.charAt(0).toUpperCase() + agentKey.slice(1)) : 'Jeremy',
                  authorId: isBot ? agentKey : 'user',
                  isBot,
                  timestamp: m.timestamp || Date.now(),
                  timestampFormatted: m.timestamp
                    ? new Date(m.timestamp).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })
                    : ''
                };
              })
              .filter(m => m.content.trim());

            if (gwMessages.length > 0) {
              chatMessagesCache = gwMessages;
              renderChatMessages(gwMessages);
            }
          }
        } catch (e) {
          console.log('[GW] History fetch failed:', e.message || e);
        }
      }

      // If Gateway didn't load messages, try cache fallback
      if (chatMessagesCache.length === 0) {
        try {
          const response = await fetch(`${API_BASE}/chat/${agentKey}`);
          const data = await response.json();
          if (data.ok && data.messages && data.messages.length > 0) {
            chatMessagesCache = data.messages;
            renderChatMessages(data.messages);
          } else {
            chatMessages.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">Start a conversation...</div>';
          }
        } catch (e) {
          console.log('Cache fetch failed:', e);
          chatMessages.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">Start a conversation...</div>';
        }
      }

      // If this agent has a pending streaming message, append it now
      const state = getStreamingState(agentKey);
      if (state.el && !state.el.parentElement) {
        chatMessages.appendChild(state.el);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }

      // Register streaming callback for this agent's session
      const sessionKey = agentSessionKey(agentKey);
      console.log('[CALLBACK] Registering callback for:', sessionKey);
      console.log('[CALLBACK] Total callbacks registered:', gwChatCallbacks.size);
      gwChatCallbacks.set(sessionKey, {
        onDelta: (text, payload) => {
          updateStreamingText(agentKey, text);
        },
        onFinal: (payload) => {
          // Save final agent response to server cache
          const state = getStreamingState(agentKey);
          if (state.text) {
            fetch(`${API_BASE}/messages/${agentKey}/agent-reply`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ content: state.text })
            }).catch(() => {});

            // Mark as unread if we're not currently viewing this agent
            markUnread(agentKey);
          }
          finalizeStreaming(agentKey);
        },
        onError: (payload) => {
          console.error('[GW] Chat error:', payload);
          finalizeStreaming(agentKey);
        }
      });
    }

    // Parse natural language for movement commands
    function parseNaturalLanguage(text, currentAgent) {
      const lower = text.toLowerCase();
      const agentNames = ['isla', 'marcus', 'harper', 'eli', 'sage', 'dash', 'julie', 'remy', 'lena', 'val'];

      console.log('[NL Parser] Checking:', text, 'Current agent:', currentAgent);

      // Meeting/standup triggers
      if (lower.match(/\b(standup|stand[\s-]?up|daily|meeting|gather|conference)\b/)) {
        if (lower.match(/\b(everyone|all|team|agents)\b/) || lower.includes('time')) {
          showMovementNotification('üìÖ Everyone is heading to the conference room...');
          startMeeting('standup');
          return { handled: true, silent: false }; // Let agent respond too
        }
      }

      // End meeting triggers
      if (lower.match(/\b(back to|return to|end|dismiss|done)\b/) && lower.match(/\b(desk|desks|meeting)\b/)) {
        showMovementNotification('‚úÖ Meeting ended - everyone returning to desks');
        endMeeting();
        return { handled: true, silent: false };
      }

      // Talk to / meet with / go see patterns
      const talkPatterns = [
        /\b(?:go\s+)?(?:talk|speak|chat|meet|ask)\s+(?:(?:to|with)\s+)?(\w+)/i,
        /\b(?:go\s+)?(?:see|visit|check in with|sync with)\s+(\w+)/i,
        /\b(?:walk|head|hop|swing)\s+(?:over\s+)?(?:to\s+)?(\w+)/i,
        /\bcoordinate\s+with\s+(\w+)/i,
        /\bdiscuss\s+(?:this\s+)?(?:with\s+)?(\w+)/i,
      ];

      for (const pattern of talkPatterns) {
        const match = text.match(pattern);
        if (match) {
          console.log('[NL Parser] Pattern matched:', pattern, 'Target:', match[1]);
          const targetAgent = match[1].toLowerCase();
          console.log('[NL Parser] Target agent:', targetAgent, 'Current:', currentAgent, 'Valid:', agentNames.includes(targetAgent));

          if (agentNames.includes(targetAgent) && targetAgent !== currentAgent) {
            console.log('[NL Parser] ‚úÖ Movement triggered!');
            // Show notification
            const currentName = currentAgent.charAt(0).toUpperCase() + currentAgent.slice(1);
            const targetName = targetAgent.charAt(0).toUpperCase() + targetAgent.slice(1);
            showMovementNotification(`${currentName} is walking over to ${targetName}...`);

            // Move current agent to target agent IMMEDIATELY (not delayed)
            console.log('[NL Parser] Calling moveForChat now...');
            moveForChat(currentAgent, targetAgent);

            // Return to desk after 8 seconds
            setTimeout(() => {
              console.log('[NL Parser] Returning to desk...');
              returnToDesk(currentAgent);
              showMovementNotification(`${currentName} returned to their desk`);
            }, 8000);
            return { handled: true, silent: false }; // Continue with message
          } else {
            console.log('[NL Parser] ‚ùå Skipped - same agent or invalid');
          }
        }
      }

      return { handled: false, silent: false };
    }

    // Check for special commands
    function handleSpecialCommands(text) {
      const cmd = text.toLowerCase().trim();

      // Meeting commands
      if (cmd === '/standup' || cmd === '/meeting') {
        startMeeting('standup');
        return { handled: true, response: 'üìÖ Starting standup - everyone to the conference room!' };
      }

      if (cmd === '/endmeeting' || cmd === '/desks') {
        endMeeting();
        return { handled: true, response: '‚úÖ Meeting ended - back to your desks!' };
      }

      // Manual interaction trigger (for testing)
      const interactionMatch = cmd.match(/^\/talk\s+(\w+)\s+(\w+)$/);
      if (interactionMatch) {
        const [, agentA, agentB] = interactionMatch;
        moveForChat(agentA, agentB);
        return { handled: true, response: `üí¨ ${agentA} is talking with ${agentB}` };
      }

      // Return to desk command
      const deskMatch = cmd.match(/^\/desk\s+(\w+)$/);
      if (deskMatch) {
        const agent = deskMatch[1];
        returnToDesk(agent);
        return { handled: true, response: `üö∂ ${agent} returned to their desk` };
      }

      // Help command
      if (cmd === '/help' || cmd === '/commands') {
        return {
          handled: true,
          response: `**Office Controls:**

**Natural Language:**
- "Go talk to Isla about XYZ"
- "Everyone gather for standup"
- "Meeting time"
- "Back to your desks"
- "See Marcus about the PR"

**Slash Commands:**
/standup - Start a meeting
/endmeeting - End meeting
/talk [agent1] [agent2] - Make agents chat
/desk [agent] - Send agent to desk`
        };
      }

      return { handled: false };
    }

    // Send message via Gateway WebSocket
    async function sendMessage() {
      const text = chatInput.value.trim();
      if (!text || !currentAgentKey) return;

      console.log('[SEND] Sending message:', text.substring(0, 50));

      // Check for natural language movement triggers
      const nlResult = parseNaturalLanguage(text, currentAgentKey);

      // Check for special slash commands
      const cmdResult = handleSpecialCommands(text);
      if (cmdResult.handled) {
        chatInput.value = '';
        chatInput.style.height = 'auto'; // Reset height
        delete messageDrafts[currentAgentKey]; // Clear draft
        // Show system message
        const sysEl = document.createElement('div');
        sysEl.style.cssText = 'text-align: center; padding: 12px; margin: 8px 0; background: rgba(14, 165, 233, 0.1); border-radius: 8px; font-size: 0.85rem;';
        sysEl.innerHTML = formatMarkdown(cmdResult.response);
        chatMessages.appendChild(sysEl);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        chatInput.focus();
        return;
      }

      // Clear input immediately (but don't disable it)
      chatInput.value = '';
      chatInput.style.height = 'auto'; // Reset height after sending

      // Clear draft for this agent
      delete messageDrafts[currentAgentKey];

      // Show user message immediately
      appendUserMessage(text);

      // Save to server cache (for cross-device sync) - cache only, no gateway send
      fetch(`${API_BASE}/chat/${currentAgentKey}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ message: text, cacheOnly: true })
      }).catch(e => console.log('Failed to cache message:', e));

      // Send via Gateway WebSocket (sole delivery path)
      if (gwConnected) {
        try {
          const sessionKey = agentSessionKey(currentAgentKey);
          const idempKey = `office-${Date.now()}-${Math.random().toString(36).slice(2)}`;
          console.log('[SEND] Sending to Gateway with sessionKey:', sessionKey);
          console.log('[SEND] Idempotency key:', idempKey);

          await gwRequest('chat.send', {
            sessionKey,
            message: text,
            idempotencyKey: idempKey
          });
          // Response streaming handled by gwChatCallbacks
        } catch (e) {
          console.error('[GW] chat.send failed:', e);
          // Show error in chat
          const errEl = document.createElement('div');
          errEl.style.cssText = 'text-align: center; color: #f59e0b; padding: 8px; font-size: 0.8rem;';
          errEl.textContent = `Failed to send: ${e.message || 'WebSocket not connected'}`;
          chatMessages.appendChild(errEl);
          chatMessages.scrollTop = chatMessages.scrollHeight;
        }
      } else {
        // Fallback: show not connected message
        const errEl = document.createElement('div');
        errEl.style.cssText = 'text-align: center; color: #f59e0b; padding: 8px; font-size: 0.8rem;';
        errEl.textContent = 'Gateway not connected. Reconnecting...';
        chatMessages.appendChild(errEl);
        gwConnect();
      }

      // Keep input focused for quick follow-ups
      chatInput.focus();
    }

    // Disabled polling - messages show via streaming, no need for polling refresh
    // (Polling was causing duplicates by re-rendering messages already shown via WebSocket)

    // Auto-resize textarea as user types
    function autoResizeTextarea() {
      chatInput.style.height = 'auto';
      chatInput.style.height = Math.min(chatInput.scrollHeight, 200) + 'px';
    }

    // Debounced draft save
    let draftSaveTimer = null;
    function onInputChange() {
      autoResizeTextarea();

      // Debounce draft saving (save 500ms after user stops typing)
      clearTimeout(draftSaveTimer);
      draftSaveTimer = setTimeout(() => {
        saveDraftForCurrentAgent();
      }, 500);
    }

    chatInput.addEventListener('input', onInputChange);

    chatSend.addEventListener('click', sendMessage);
    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });

    // --- Mobile Menu Controls ---
    const mobileMenuBtn = document.getElementById('mobileMenuBtn');
    const leftInfoPanel = document.querySelector('.left-info-panel');
    const panelOverlay = document.getElementById('panelOverlay');

    // Initialize panel as hidden on mobile and ensure overlay is not active
    if (window.innerWidth <= 768) {
      leftInfoPanel.classList.add('mobile-hidden');
      leftInfoPanel.classList.remove('mobile-visible');
      panelOverlay.classList.remove('active'); // Ensure overlay is hidden on load
    }

    // Toggle left panel on mobile
    if (mobileMenuBtn) {
      mobileMenuBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        console.log('Hamburger menu clicked');

        const isVisible = leftInfoPanel.classList.contains('mobile-visible');

        if (isVisible) {
          leftInfoPanel.classList.remove('mobile-visible');
          leftInfoPanel.classList.add('mobile-hidden');
          panelOverlay.classList.remove('active');
        } else {
          leftInfoPanel.classList.remove('mobile-hidden');
          leftInfoPanel.classList.add('mobile-visible');
          panelOverlay.classList.add('active');
        }
      });
    }

    // Close panels when clicking overlay
    if (panelOverlay) {
      panelOverlay.addEventListener('click', () => {
        // Close left panel
        if (leftInfoPanel.classList.contains('mobile-visible')) {
          leftInfoPanel.classList.remove('mobile-visible');
          leftInfoPanel.classList.add('mobile-hidden');
        }
        // Close right panel
        if (!sidePanel.classList.contains('hidden')) {
          sidePanel.classList.add('hidden');
          if (selectedAgent) {
            selectedAgent.classList.remove('selected');
            selectedAgent = null;
          }
        }
        panelOverlay.classList.remove('active');
      });
    }

    // --- Mobile Bottom Navigation ---
    const mobileBottomNav = document.getElementById('mobileBottomNav');
    const mobileNavItems = document.querySelectorAll('.mobile-nav-item');

    // Handle mobile nav clicks
    mobileNavItems.forEach(navItem => {
      navItem.addEventListener('click', () => {
        const agentKey = navItem.dataset.agent;

        // Find the corresponding agent element
        const agent = document.querySelector(`.agent.${agentKey}`);
        if (agent) {
          agent.click(); // Trigger existing click handler
        }

        // Update active state
        mobileNavItems.forEach(item => item.classList.remove('active'));
        navItem.classList.add('active');

        // Show side panel on mobile
        sidePanel.classList.remove('hidden');
      });
    });

    // Update mobile nav active state when agent changes
    function updateMobileNavActive(agentKey) {
      mobileNavItems.forEach(item => {
        if (item.dataset.agent === agentKey) {
          item.classList.add('active');
        } else {
          item.classList.remove('active');
        }
      });
    }

    // Override agent click to show overlay on mobile
    const originalAgentClick = agents.forEach;
    agents.forEach(agent => {
      const existingListener = agent.onclick;
      agent.addEventListener('click', () => {
        // Update mobile nav when agent clicked from office view
        const agentKey = agent.classList[1];
        updateMobileNavActive(agentKey);

        // Show overlay on tablet (not on mobile since chat is primary interface there)
        if (window.innerWidth > 768 && window.innerWidth <= 1200) {
          panelOverlay.classList.add('active');
        }
      });
    });

    // --- Panel Resize ---
    const resizeHandle = document.getElementById('resizeHandle');
    let isResizing = false;
    let startX = 0;
    let startWidth = 0;

    // Load saved width from localStorage
    const savedWidth = localStorage.getItem('sidePanelWidth');
    if (savedWidth) {
      sidePanel.style.width = savedWidth + 'px';
    }

    resizeHandle.addEventListener('mousedown', (e) => {
      isResizing = true;
      startX = e.clientX;
      startWidth = sidePanel.offsetWidth;
      resizeHandle.classList.add('dragging');
      document.body.style.cursor = 'ew-resize';
      document.body.style.userSelect = 'none';
      e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
      if (!isResizing) return;

      const deltaX = startX - e.clientX; // Dragging left increases width
      const newWidth = Math.max(300, Math.min(800, startWidth + deltaX));
      sidePanel.style.width = newWidth + 'px';
    });

    document.addEventListener('mouseup', () => {
      if (isResizing) {
        isResizing = false;
        resizeHandle.classList.remove('dragging');
        document.body.style.cursor = '';
        document.body.style.userSelect = '';

        // Save width to localStorage
        localStorage.setItem('sidePanelWidth', sidePanel.offsetWidth);
      }
    });

    // --- Mobile: Auto-open Isla's chat on load ---
    if (window.innerWidth <= 768) {
      // On mobile, open Isla's chat by default
      setTimeout(() => {
        const islaAgent = document.querySelector('.agent.isla');
        if (islaAgent) {
          islaAgent.click();
        }
      }, 500);
    }
  </script>
</body>
</html>
